import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class JumpPointSearch extends Algorithm{constructor(t){super(t)}solve(){this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.h=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.startNode.distance=0,this.startNode.g=0,this.startNode.h=this.calculateHeuristic(this.startNode,this.finishNode),this.startNode.f=this.startNode.g+this.startNode.h,this.startNode.in_open_set=!0;const t=[this.startNode];for(;t.length>0;){t.sort(((t,s)=>t.f-s.f));const s=t.shift();s.in_open_set=!1;const i=this.get_1d_index(s.row,s.col);if(s===this.finishNode)break;s.is_visited||s.is_wall||(s.is_visited=!0,this.steps.push({type:"visited",indices:[i]}),this.updateNeighbors(s,t))}return this.steps.push({type:"finish",indices:this.getPath()}),this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.h=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.steps}updateNeighbors(t,s){const i=this.getNeighbors(t);for(const e of i){if(e.is_wall||e.is_visited)continue;const i=t.g+1;if(i<e.g){const o=this.get_1d_index(e.row,e.col);e.prev=t,e.g=i,e.distance=i,e.h=this.calculateHeuristic(e,this.finishNode),e.f=e.g+e.h,e.in_open_set||(e.in_open_set=!0,s.push(e)),this.steps.push({type:"updated",indices:[o]})}}}getNeighbors(t){const s=[],{row:i,col:e}=t,{rows:o,cols:h}=this;return i>0&&s.push(this.nodes[this.get_1d_index(i-1,e)]),i<o-1&&s.push(this.nodes[this.get_1d_index(i+1,e)]),e>0&&s.push(this.nodes[this.get_1d_index(i,e-1)]),e<h-1&&s.push(this.nodes[this.get_1d_index(i,e+1)]),s}calculateHeuristic(t,s){return Math.abs(t.row-s.row)+Math.abs(t.col-s.col)}getPath(){const t=[];let s=this.finishNode;for(;null!==s;)t.unshift(this.get_1d_index(s.row,s.col)),s=s.prev;return t}}
//# sourceMappingURL=jps.js.map