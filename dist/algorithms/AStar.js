import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class Astar extends Algorithm{constructor(t){super(t)}solve(){for(this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.startNode.distance=0,this.startNode.g=0,this.startNode.f=this.heuristic(this.startNode,this.finishNode),this.startNode.in_open_set=!0,this.openSet=[this.startNode];this.openSet.length>0;){this.sortByHeuristic(this.openSet);let t=this.openSet.shift();t.in_open_set=!1,t.is_visited=!0;let s=this.get_1d_index(t.row,t.col);if(!t.is_wall){if(this.steps.push({type:"visited",indices:[s]}),t===this.finishNode)break;this.updateNeighbors(t)}}return this.steps.push({type:"finish",indices:this.aStarGetPath()}),this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.steps}heuristic(t,s){return Math.abs(t.row-s.row)+Math.abs(t.col-s.col)}aStarGetPath(t=this.finishNode){const s=[];let i=t;for(;null!==i;)s.unshift(this.get_1d_index(i.row,i.col)),i=i.prev;return s}updateNeighbors(t){const s=this.getNeighbors(t);for(const i of s){if(i.is_wall||i.is_visited)continue;const s=t.g+1;if(s<i.g){const e=this.get_1d_index(i.row,i.col);i.prev=t,i.g=s,i.distance=s,i.f=s+this.heuristic(i,this.finishNode),i.in_open_set||(i.in_open_set=!0,this.openSet.push(i)),this.steps.push({type:"updated",indices:[e]})}}}getNeighbors(t){const s=[],{row:i,col:e}=t,{rows:o,cols:h}=this;return i>0&&s.push(this.nodes[this.get_1d_index(i-1,e)]),i<o-1&&s.push(this.nodes[this.get_1d_index(i+1,e)]),e>0&&s.push(this.nodes[this.get_1d_index(i,e-1)]),e<h-1&&s.push(this.nodes[this.get_1d_index(i,e+1)]),s}sortByHeuristic(t){t.sort(((t,s)=>t.f-s.f))}}
//# sourceMappingURL=AStar.js.map