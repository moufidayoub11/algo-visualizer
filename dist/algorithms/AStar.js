import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class Astar extends Algorithm{constructor(t){super(t)}solve(){this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.startNode.distance=0,this.startNode.g=0;const t=this.heuristic(this.startNode,this.finishNode);for(this.startNode.f=this.startNode.g+t,this.startNode.in_open_set=!0,this.openSet=[this.startNode];this.openSet.length>0;){this.sortByHeuristic(this.openSet);let t=this.openSet.shift();t.in_open_set=!1;let s=this.get_1d_index(t.row,t.col);if(t===this.finishNode)break;t.is_wall||t.is_visited||(t.is_visited=!0,this.steps.push({type:"visited",indices:[s]}),this.updateNeighbors(t))}return this.steps.push({type:"finish",indices:this.aStarGetPath()}),this.nodes.forEach((t=>{t.distance=1/0,t.f=1/0,t.g=1/0,t.is_visited=!1,t.in_open_set=!1,t.prev=null})),this.steps}heuristic(t,s){return 1.05*(Math.abs(t.row-s.row)+Math.abs(t.col-s.col))}aStarGetPath(t=this.finishNode){const s=[];let i=t;for(;null!==i;)s.unshift(this.get_1d_index(i.row,i.col)),i=i.prev;return s}updateNeighbors(t){const s=this.getNeighbors(t);for(const i of s){if(i.is_wall||i.is_visited)continue;const s=t.g+1;if(s<i.g){const e=this.get_1d_index(i.row,i.col);i.prev=t,i.g=s,i.distance=s,i.f=s+this.heuristic(i,this.finishNode),i.in_open_set||(i.in_open_set=!0,this.openSet.push(i)),this.steps.push({type:"updated",indices:[e]})}}}getNeighbors(t){const s=[],{row:i,col:e}=t,{rows:h,cols:o}=this;return i>0&&s.push(this.nodes[this.get_1d_index(i-1,e)]),i<h-1&&s.push(this.nodes[this.get_1d_index(i+1,e)]),e>0&&s.push(this.nodes[this.get_1d_index(i,e-1)]),e<o-1&&s.push(this.nodes[this.get_1d_index(i,e+1)]),s}sortByHeuristic(t){t.sort(((t,s)=>{if(t.f!==s.f)return t.f-s.f;return this.heuristic(t,this.finishNode)-this.heuristic(s,this.finishNode)}))}}
//# sourceMappingURL=AStar.js.map