{"version":3,"sources":["dijkstra.js"],"names":["Node","Algorithm","Dijkstra","constructor","nodes","super","solve","node","this","distance","Infinity","is_visited","prev","startNode","unvisited_list","slice","length","sortByDistance","closest","shift","closestIndex","get_1d_index","row","col","is_wall","steps","push","type","indices","finishNode","updateNeighbors","dijkstraGetPath","current","shortestPath","curr","unshift","neighbors","getNeighbors","neigh","index","rows","cols","filter","ng_node","sort","node1","node2"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,iBAAiBD,UAElCE,WAAAA,CAAYC,GACRC,MAAMD,EACT,CAEDE,KAAAA,GACI,IAAK,IAAIC,KAAQC,KAAKJ,MAClBG,EAAKE,SAAWC,IAChBH,EAAKI,YAAa,EAClBJ,EAAKK,KAAO,KAEhBJ,KAAKK,UAAUJ,SAAW,EAE1B,IAAIK,EAAiBN,KAAKJ,MAAMW,QAEhC,KAASD,EAAeE,QAAQ,CAC5BR,KAAKS,eAAeH,GACpB,IAAII,EAAUJ,EAAeK,QACzBC,EAAeZ,KAAKa,aAAaH,EAAQI,IAAKJ,EAAQK,KAE1D,IAAIL,EAAQM,QAAZ,CACA,GAAIN,EAAQT,UAAYC,IAAU,MAMlC,GAJAQ,EAAQP,YAAa,EAErBH,KAAKiB,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACR,KAEzCF,GAAWV,KAAKqB,WAAY,MAEhCrB,KAAKsB,gBAAgBZ,EAASV,KAAKJ,MATd,CAUxB,CAEDI,KAAKiB,MAAMC,KAAK,CAAEC,KAAM,SAAUC,QAASpB,KAAKuB,oBAEhD,IAAK,IAAIxB,KAAQC,KAAKJ,MAClBG,EAAKE,SAAWC,IAChBH,EAAKI,YAAa,EAClBJ,EAAKK,KAAO,KAEhB,OAAOJ,KAAKiB,KACf,CAEDM,eAAAA,CAAgBC,EAAUxB,KAAKqB,YAC3B,MAAMI,EAAe,GACrB,IAAIC,EAAOF,EAEX,KAAgB,OAATE,GACHD,EAAaE,QAAQ3B,KAAKa,aAAaa,EAAKZ,IAAKY,EAAKX,MACtDW,EAAOA,EAAKtB,KAEhB,OAAOqB,CACV,CAMDH,eAAAA,CAAgBvB,EAAMH,GAClB,IAAIgC,EAAY5B,KAAK6B,aAAa9B,EAAMH,GAExC,IAAK,IAAIkC,KAASF,EAAW,CAEzB,GADmB7B,EAAKE,SAAW,EAChB6B,EAAM7B,SAAU,CAC/B,MAAM8B,EAAQ/B,KAAKa,aAAaiB,EAAMhB,IAAKgB,EAAMf,KACjDe,EAAM7B,SAAWF,EAAKE,SAAW,EACjC6B,EAAM1B,KAAOL,EACbC,KAAKiB,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACW,IAChD,CACJ,CACJ,CAMDF,YAAAA,CAAa9B,EAAMH,GACf,MAAMgC,EAAY,GAClB,IAAId,EAAMf,EAAKe,IACXC,EAAMhB,EAAKgB,IACXiB,EAAOhC,KAAKgC,KACZC,EAAOjC,KAAKiC,KAUhB,OARInB,EAAM,GAAGc,EAAUV,KAAKtB,EAAMI,KAAKa,aAAaC,EAAM,EAAGC,KACzDD,EAAMkB,EAAO,GACbJ,EAAUV,KAAKtB,EAAMI,KAAKa,aAAaC,EAAM,EAAGC,KAEhDA,EAAM,GAAGa,EAAUV,KAAKtB,EAAMI,KAAKa,aAAaC,EAAKC,EAAM,KAC3DA,EAAMkB,EAAO,GACbL,EAAUV,KAAKtB,EAAMI,KAAKa,aAAaC,EAAKC,EAAM,KAE/Ca,EAAUM,QACZC,IAAaA,EAAQhC,aAAegC,EAAQnB,SAEpD,CAKDP,cAAAA,CAAeb,GACXA,EAAMwC,MAAK,CAACC,EAAOC,IAAUD,EAAMpC,SAAWqC,EAAMrC,UACvD","file":"dijkstra.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class Dijkstra extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        this.startNode.distance = 0;\n\n        let unvisited_list = this.nodes.slice();\n\n        while (!!unvisited_list.length) {\n            this.sortByDistance(unvisited_list);\n            let closest = unvisited_list.shift();\n            let closestIndex = this.get_1d_index(closest.row, closest.col);\n\n            if (closest.is_wall) continue;\n            if (closest.distance == Infinity) break;\n\n            closest.is_visited = true;\n\n            this.steps.push({ type: \"visited\", indices: [closestIndex] });\n\n            if (closest == this.finishNode) break;\n\n            this.updateNeighbors(closest, this.nodes);\n        }\n\n        this.steps.push({ type: \"finish\", indices: this.dijkstraGetPath() });\n\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        return this.steps;\n    }\n\n    dijkstraGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    /**\n     * @param {Node} node - Node to update neighbors\n     * @param {Node[]} nodes - The nodes array\n     */\n    updateNeighbors(node, nodes) {\n        let neighbors = this.getNeighbors(node, nodes);\n\n        for (let neigh of neighbors) {\n            let new_distance = node.distance + 1;\n            if (new_distance < neigh.distance) {\n                const index = this.get_1d_index(neigh.row, neigh.col);\n                neigh.distance = node.distance + 1;\n                neigh.prev = node;\n                this.steps.push({ type: \"updated\", indices: [index] });\n            }\n        }\n    }\n\n    /**\n     * @param {Node} node - Node to update neighbors\n     * @param {Node[]} nodes - The nodes array\n     */\n    getNeighbors(node, nodes) {\n        const neighbors = [];\n        let row = node.row;\n        let col = node.col;\n        let rows = this.rows;\n        let cols = this.cols;\n\n        if (row > 0) neighbors.push(nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(nodes[this.get_1d_index(row + 1, col)]);\n\n        if (col > 0) neighbors.push(nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors.filter(\n            (ng_node) => !ng_node.is_visited && !ng_node.is_wall\n        );\n    }\n\n    /**\n     * @param {Node[]} nodes - The nodes array\n     */\n    sortByDistance(nodes) {\n        nodes.sort((node1, node2) => node1.distance - node2.distance);\n    }\n}\n"]}