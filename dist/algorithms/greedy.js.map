{"version":3,"sources":["greedy.js"],"names":["Node","Algorithm","GreedyBestFirstSearch","constructor","nodes","super","solve","node","this","distance","Infinity","is_visited","prev","f","calculateHeuristic","finishNode","in_open_set","startNode","openSet","length","sort","a","b","current","shift","currentIndex","get_1d_index","row","col","is_wall","steps","push","type","indices","updateNeighbors","getPath","neighbors","getNeighbors","neighbor","tentativeDistance","neighborIndex","rows","cols","nodeA","nodeB","Math","abs","shortestPath","unshift"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,8BAA8BD,UAC/CE,WAAAA,CAAYC,GACRC,MAAMD,EACT,CAEDE,KAAAA,GACI,IAAK,IAAIC,KAAQC,KAAKJ,MAClBG,EAAKE,SAAWC,IAChBH,EAAKI,YAAa,EAClBJ,EAAKK,KAAO,KACZL,EAAKM,EAAIL,KAAKM,mBAAmBP,EAAMC,KAAKO,YAC5CR,EAAKS,aAAc,EAGvBR,KAAKS,UAAUR,SAAW,EAC1BD,KAAKS,UAAUJ,EAAIL,KAAKM,mBAAmBN,KAAKS,UAAWT,KAAKO,YAChEP,KAAKS,UAAUD,aAAc,EAE7B,MAAME,EAAU,CAACV,KAAKS,WAEtB,KAAOC,EAAQC,OAAS,GAAG,CAEvBD,EAAQE,MAAK,CAACC,EAAGC,IAAMD,EAAER,EAAIS,EAAET,IAE/B,MAAMU,EAAUL,EAAQM,QACxBD,EAAQP,aAAc,EAEtB,MAAMS,EAAejB,KAAKkB,aAAaH,EAAQI,IAAKJ,EAAQK,KAE5D,GAAIL,IAAYf,KAAKO,WAAY,MAE7BQ,EAAQZ,YAAcY,EAAQM,UAElCN,EAAQZ,YAAa,EACrBH,KAAKsB,MAAMC,KAAK,CACZC,KAAM,UACNC,QAAS,CAACR,KAGdjB,KAAK0B,gBAAgBX,EAASL,GACjC,CAOD,OALAV,KAAKsB,MAAMC,KAAK,CACZC,KAAM,SACNC,QAASzB,KAAK2B,YAGX3B,KAAKsB,KACf,CAEDI,eAAAA,CAAgBX,EAASL,GACrB,MAAMkB,EAAY5B,KAAK6B,aAAad,GAEpC,IAAK,MAAMe,KAAYF,EAAW,CAC9B,GAAIE,EAAS3B,YAAc2B,EAAST,QAAS,SAE7C,MAAMU,EAAoBhB,EAAQd,SAAW,EAE7C,GAAI8B,EAAoBD,EAAS7B,SAAU,CACvC6B,EAAS7B,SAAW8B,EACpBD,EAAS1B,KAAOW,EAChBe,EAASzB,EAAIL,KAAKM,mBAAmBwB,EAAU9B,KAAKO,YAE/CuB,EAAStB,cACVsB,EAAStB,aAAc,EACvBE,EAAQa,KAAKO,IAGjB,MAAME,EAAgBhC,KAAKkB,aAAaY,EAASX,IAAKW,EAASV,KAC/DpB,KAAKsB,MAAMC,KAAK,CACZC,KAAM,UACNC,QAAS,CAACO,IAEjB,CACJ,CACJ,CAEDH,YAAAA,CAAa9B,GACT,MAAM6B,EAAY,IACZT,IAAEA,EAAFC,IAAOA,GAAQrB,GACfkC,KAAEA,EAAFC,KAAQA,GAASlC,KAWvB,OATImB,EAAM,GACNS,EAAUL,KAAKvB,KAAKJ,MAAMI,KAAKkB,aAAaC,EAAM,EAAGC,KACrDD,EAAMc,EAAO,GACbL,EAAUL,KAAKvB,KAAKJ,MAAMI,KAAKkB,aAAaC,EAAM,EAAGC,KACrDA,EAAM,GACNQ,EAAUL,KAAKvB,KAAKJ,MAAMI,KAAKkB,aAAaC,EAAKC,EAAM,KACvDA,EAAMc,EAAO,GACbN,EAAUL,KAAKvB,KAAKJ,MAAMI,KAAKkB,aAAaC,EAAKC,EAAM,KAEpDQ,CACV,CAEDtB,kBAAAA,CAAmB6B,EAAOC,GAEtB,OAAOC,KAAKC,IAAIH,EAAMhB,IAAMiB,EAAMjB,KAAOkB,KAAKC,IAAIH,EAAMf,IAAMgB,EAAMhB,IACvE,CAEDO,OAAAA,GACI,MAAMY,EAAe,GACrB,IAAIxB,EAAUf,KAAKO,WAEnB,KAAmB,OAAZQ,GACHwB,EAAaC,QAAQxC,KAAKkB,aAAaH,EAAQI,IAAKJ,EAAQK,MAC5DL,EAAUA,EAAQX,KAGtB,OAAOmC,CACV","file":"greedy.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class GreedyBestFirstSearch extends Algorithm {\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n            node.f = this.calculateHeuristic(node, this.finishNode); // Use f for heuristic in greedy\n            node.in_open_set = false;\n        }\n\n        this.startNode.distance = 0;\n        this.startNode.f = this.calculateHeuristic(this.startNode, this.finishNode);\n        this.startNode.in_open_set = true;\n        \n        const openSet = [this.startNode];\n\n        while (openSet.length > 0) {\n            // Sort by heuristic only (greedy approach) - using f property\n            openSet.sort((a, b) => a.f - b.f);\n            \n            const current = openSet.shift();\n            current.in_open_set = false;\n            \n            const currentIndex = this.get_1d_index(current.row, current.col);\n\n            if (current === this.finishNode) break;\n\n            if (current.is_visited || current.is_wall) continue;\n\n            current.is_visited = true;\n            this.steps.push({\n                type: \"visited\",\n                indices: [currentIndex],\n            });\n\n            this.updateNeighbors(current, openSet);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.getPath(),\n        });\n\n        return this.steps;\n    }\n\n    updateNeighbors(current, openSet) {\n        const neighbors = this.getNeighbors(current);\n\n        for (const neighbor of neighbors) {\n            if (neighbor.is_visited || neighbor.is_wall) continue;\n\n            const tentativeDistance = current.distance + 1;\n\n            if (tentativeDistance < neighbor.distance) {\n                neighbor.distance = tentativeDistance;\n                neighbor.prev = current;\n                neighbor.f = this.calculateHeuristic(neighbor, this.finishNode); // Use f property\n\n                if (!neighbor.in_open_set) {\n                    neighbor.in_open_set = true;\n                    openSet.push(neighbor);\n                }\n\n                const neighborIndex = this.get_1d_index(neighbor.row, neighbor.col);\n                this.steps.push({\n                    type: \"updated\",\n                    indices: [neighborIndex],\n                });\n            }\n        }\n    }\n\n    getNeighbors(node) {\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors;\n    }\n\n    calculateHeuristic(nodeA, nodeB) {\n        // Manhattan distance heuristic\n        return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\n    }\n\n    getPath() {\n        const shortestPath = [];\n        let current = this.finishNode;\n\n        while (current !== null) {\n            shortestPath.unshift(this.get_1d_index(current.row, current.col));\n            current = current.prev;\n        }\n\n        return shortestPath;\n    }\n}\n"]}