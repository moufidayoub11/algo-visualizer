import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class GreedyBestFirstSearch extends Algorithm{constructor(s){super(s)}solve(){for(let s of this.nodes)s.distance=1/0,s.is_visited=!1,s.prev=null,s.f=this.calculateHeuristic(s,this.finishNode),s.in_open_set=!1;this.startNode.distance=0,this.startNode.f=this.calculateHeuristic(this.startNode,this.finishNode),this.startNode.in_open_set=!0;const s=[this.startNode];for(;s.length>0;){s.sort(((s,t)=>s.f-t.f));const t=s.shift();t.in_open_set=!1;const i=this.get_1d_index(t.row,t.col);if(t===this.finishNode)break;t.is_visited||t.is_wall||(t.is_visited=!0,this.steps.push({type:"visited",indices:[i]}),this.updateNeighbors(t,s))}return this.steps.push({type:"finish",indices:this.getPath()}),this.steps}updateNeighbors(s,t){const i=this.getNeighbors(s);for(const e of i){if(e.is_visited||e.is_wall)continue;const i=s.distance+1;if(i<e.distance){e.distance=i,e.prev=s,e.f=this.calculateHeuristic(e,this.finishNode),e.in_open_set||(e.in_open_set=!0,t.push(e));const o=this.get_1d_index(e.row,e.col);this.steps.push({type:"updated",indices:[o]})}}}getNeighbors(s){const t=[],{row:i,col:e}=s,{rows:o,cols:h}=this;return i>0&&t.push(this.nodes[this.get_1d_index(i-1,e)]),i<o-1&&t.push(this.nodes[this.get_1d_index(i+1,e)]),e>0&&t.push(this.nodes[this.get_1d_index(i,e-1)]),e<h-1&&t.push(this.nodes[this.get_1d_index(i,e+1)]),t}calculateHeuristic(s,t){return Math.abs(s.row-t.row)+Math.abs(s.col-t.col)}getPath(){const s=[];let t=this.finishNode;for(;null!==t;)s.unshift(this.get_1d_index(t.row,t.col)),t=t.prev;return s}}
//# sourceMappingURL=greedy.js.map