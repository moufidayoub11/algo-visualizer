{"version":3,"sources":["dfs.js"],"names":["Node","Algorithm","DepthFirstSearch","constructor","nodes","super","solve","node","this","distance","Infinity","is_visited","prev","openSet","startNode","length","closest","pop","finishNode","closestIndex","get_1d_index","row","col","is_wall","steps","push","type","indices","updateNeighbors","dfsGetPath","current","shortestPath","curr","unshift","neighbors","getNeighbors","neighbor","index","rows","cols","filter"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,yBAAyBD,UAE1CE,WAAAA,CAAYC,GACRC,MAAMD,EACT,CAEDE,KAAAA,GACI,IAAK,IAAIC,KAAQC,KAAKJ,MAClBG,EAAKE,SAAWC,IAChBH,EAAKI,YAAa,EAClBJ,EAAKK,KAAO,KAIhB,IAFAJ,KAAKK,QAAU,CAACL,KAAKM,WAEZN,KAAKK,QAAQE,QAAQ,CAC1B,IAAIC,EAAUR,KAAKK,QAAQI,MAC3B,GAAID,GAAWR,KAAKU,WAAY,MAEhC,IAAIC,EAAeX,KAAKY,aAAaJ,EAAQK,IAAKL,EAAQM,KAEtDN,EAAQL,YAAcK,EAAQO,UAElCP,EAAQL,YAAa,EACrBH,KAAKgB,MAAMC,KAAK,CACZC,KAAM,UACNC,QAAS,CAACR,KAGdX,KAAKoB,gBAAgBZ,GACxB,CAOD,OALAR,KAAKgB,MAAMC,KAAK,CACZC,KAAM,SACNC,QAASnB,KAAKqB,eAGXrB,KAAKgB,KACf,CAEDK,UAAAA,CAAWC,EAAUtB,KAAKU,YACtB,MAAMa,EAAe,GACrB,IAAIC,EAAOF,EAEX,KAAgB,OAATE,GACHD,EAAaE,QAAQzB,KAAKY,aAAaY,EAAKX,IAAKW,EAAKV,MACtDU,EAAOA,EAAKpB,KAEhB,OAAOmB,CACV,CAEDH,eAAAA,CAAgBrB,GACZ,MAAM2B,EAAY1B,KAAK2B,aAAa5B,GAEpC,IAAK,MAAM6B,KAAYF,EAAW,CAC9B,MAAMG,EAAQ7B,KAAKY,aAAagB,EAASf,IAAKe,EAASd,KACvDc,EAASxB,KAAOL,EAChB6B,EAAS3B,UAAY,GACrBD,KAAKgB,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACU,KAC7C7B,KAAKK,QAAQY,KAAKW,EACrB,CACJ,CAEDD,YAAAA,CAAa5B,GAET,MAAM2B,EAAY,IACZb,IAAEA,EAAFC,IAAOA,GAAQf,GACf+B,KAAEA,EAAFC,KAAQA,GAAS/B,KAWvB,OATIc,EAAM,GACNY,EAAUT,KAAKjB,KAAKJ,MAAMI,KAAKY,aAAaC,EAAKC,EAAM,KACvDA,EAAMiB,EAAO,GACbL,EAAUT,KAAKjB,KAAKJ,MAAMI,KAAKY,aAAaC,EAAKC,EAAM,KACvDD,EAAM,GACNa,EAAUT,KAAKjB,KAAKJ,MAAMI,KAAKY,aAAaC,EAAM,EAAGC,KACrDD,EAAMiB,EAAO,GACbJ,EAAUT,KAAKjB,KAAKJ,MAAMI,KAAKY,aAAaC,EAAM,EAAGC,KAElDY,EAAUM,QACZJ,IAAcA,EAASzB,aAAeyB,EAASb,SAEvD","file":"dfs.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class DepthFirstSearch extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        for (let node of this.nodes) {\n            node.distance = Infinity;\n            node.is_visited = false;\n            node.prev = null;\n        }\n        this.openSet = [this.startNode];\n\n        while (!!this.openSet.length) {\n            let closest = this.openSet.pop();\n            if (closest == this.finishNode) break;\n\n            let closestIndex = this.get_1d_index(closest.row, closest.col);\n\n            if (closest.is_visited || closest.is_wall) continue;\n\n            closest.is_visited = true;\n            this.steps.push({\n                type: \"visited\",\n                indices: [closestIndex],\n            });\n\n            this.updateNeighbors(closest);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.dfsGetPath(),\n        });\n\n        return this.steps;\n    }\n\n    dfsGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    updateNeighbors(node) {\n        const neighbors = this.getNeighbors(node);\n\n        for (const neighbor of neighbors) {\n            const index = this.get_1d_index(neighbor.row, neighbor.col);\n            neighbor.prev = node;\n            neighbor.distance = -12;\n            this.steps.push({ type: \"updated\", indices: [index] });\n            this.openSet.push(neighbor);\n        }\n    }\n\n    getNeighbors(node) {\n        /**@type {Node[]} */\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n\n        return neighbors.filter(\n            (neighbor) => !neighbor.is_visited && !neighbor.is_wall\n        );\n    }\n}\n"]}