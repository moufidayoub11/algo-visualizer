{"version":3,"sources":["jps.js"],"names":["Node","Algorithm","JumpPointSearch","constructor","nodes","super","solve","this","forEach","node","distance","Infinity","f","g","h","is_visited","in_open_set","prev","startNode","calculateHeuristic","finishNode","openSet","length","sort","a","b","current","shift","currentIndex","get_1d_index","row","col","is_wall","steps","push","type","indices","updateNeighbors","getPath","neighbors","getNeighbors","neighbor","tentativeG","index","rows","cols","nodeA","nodeB","Math","abs","shortestPath","unshift"],"mappings":"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","file":"jps.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class JumpPointSearch extends Algorithm {\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        // Initialize all nodes\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.g = Infinity;\n            node.h = Infinity;\n            node.is_visited = false;\n            node.in_open_set = false;\n            node.prev = null;\n        });\n\n        // Initialize start node\n        this.startNode.distance = 0;\n        this.startNode.g = 0;\n        this.startNode.h = this.calculateHeuristic(this.startNode, this.finishNode);\n        this.startNode.f = this.startNode.g + this.startNode.h;\n        this.startNode.in_open_set = true;\n\n        const openSet = [this.startNode];\n\n        while (openSet.length > 0) {\n            // Sort by f score (g + h)\n            openSet.sort((a, b) => a.f - b.f);\n            \n            const current = openSet.shift();\n            current.in_open_set = false;\n            \n            const currentIndex = this.get_1d_index(current.row, current.col);\n\n            // Check if we reached the goal\n            if (current === this.finishNode) break;\n\n            if (current.is_visited || current.is_wall) continue;\n\n            current.is_visited = true;\n            this.steps.push({\n                type: \"visited\",\n                indices: [currentIndex],\n            });\n\n            // Use simplified jump point logic - explore neighbors with some optimization\n            this.updateNeighbors(current, openSet);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.getPath(),\n        });\n\n        // Clean up node properties like A*\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.g = Infinity;\n            node.h = Infinity;\n            node.is_visited = false;\n            node.in_open_set = false;\n            node.prev = null;\n        });\n\n        return this.steps;\n    }\n\n    updateNeighbors(current, openSet) {\n        const neighbors = this.getNeighbors(current);\n\n        for (const neighbor of neighbors) {\n            if (neighbor.is_wall || neighbor.is_visited) continue;\n            \n            // Calculate tentative g score\n            const tentativeG = current.g + 1;\n            \n            // If this path to neighbor is better than any previous one\n            if (tentativeG < neighbor.g) {\n                const index = this.get_1d_index(neighbor.row, neighbor.col);\n                \n                // Update neighbor\n                neighbor.prev = current;\n                neighbor.g = tentativeG;\n                neighbor.distance = tentativeG; // Keep for compatibility\n                neighbor.h = this.calculateHeuristic(neighbor, this.finishNode);\n                neighbor.f = neighbor.g + neighbor.h;\n\n                // Add to open set if not already there\n                if (!neighbor.in_open_set) {\n                    neighbor.in_open_set = true;\n                    openSet.push(neighbor);\n                }\n\n                this.steps.push({ type: \"updated\", indices: [index] });\n            }\n        }\n    }\n\n    getNeighbors(node) {\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        // Get basic 4-directional neighbors\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors;\n    }\n\n    calculateHeuristic(nodeA, nodeB) {\n        // Manhattan distance heuristic\n        return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);\n    }\n\n    getPath() {\n        const shortestPath = [];\n        let current = this.finishNode;\n\n        while (current !== null) {\n            shortestPath.unshift(this.get_1d_index(current.row, current.col));\n            current = current.prev;\n        }\n\n        return shortestPath;\n    }\n}\n"]}