import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class DepthFirstSearch extends Algorithm{constructor(s){super(s)}solve(){for(let s of this.nodes)s.distance=1/0,s.is_visited=!1,s.prev=null;for(this.openSet=[this.startNode];this.openSet.length;){let s=this.openSet.pop();if(s==this.finishNode)break;let t=this.get_1d_index(s.row,s.col);s.is_visited||s.is_wall||(s.is_visited=!0,this.steps.push({type:"visited",indices:[t]}),this.updateNeighbors(s))}return this.steps.push({type:"finish",indices:this.dfsGetPath()}),this.steps}dfsGetPath(s=this.finishNode){const t=[];let e=s;for(;null!==e;)t.unshift(this.get_1d_index(e.row,e.col)),e=e.prev;return t}updateNeighbors(s){const t=this.getNeighbors(s);for(const e of t){const t=this.get_1d_index(e.row,e.col);e.prev=s,e.distance=-12,this.steps.push({type:"updated",indices:[t]}),this.openSet.push(e)}}getNeighbors(s){const t=[],{row:e,col:i}=s,{rows:o,cols:h}=this;return i>0&&t.push(this.nodes[this.get_1d_index(e,i-1)]),i<h-1&&t.push(this.nodes[this.get_1d_index(e,i+1)]),e>0&&t.push(this.nodes[this.get_1d_index(e-1,i)]),e<o-1&&t.push(this.nodes[this.get_1d_index(e+1,i)]),t.filter((s=>!s.is_visited&&!s.is_wall))}}
//# sourceMappingURL=dfs.js.map