{"version":3,"sources":["AStar.js"],"names":["Node","Algorithm","Astar","constructor","nodes","super","solve","this","forEach","node","distance","Infinity","f","g","is_visited","in_open_set","prev","startNode","startH","heuristic","finishNode","openSet","length","sortByHeuristic","current","shift","currentIndex","get_1d_index","row","col","is_wall","steps","push","type","indices","updateNeighbors","aStarGetPath","node1","node2","Math","abs","shortestPath","curr","unshift","neighbors","getNeighbors","neighbor","tentativeG","index","rows","cols","sort"],"mappings":"OAAOA,SAAU,yBACVC,cAAe,gCAEP,MAAMC,cAAcD,UAE/BE,WAAAA,CAAYC,GACRC,MAAMD,EACT,CAEDE,KAAAA,GAEIC,KAAKH,MAAMI,SAASC,IAChBA,EAAKC,SAAWC,IAChBF,EAAKG,EAAID,IACTF,EAAKI,EAAIF,IACTF,EAAKK,YAAa,EAClBL,EAAKM,aAAc,EACnBN,EAAKO,KAAO,IAAZ,IAIJT,KAAKU,UAAUP,SAAW,EAC1BH,KAAKU,UAAUJ,EAAI,EACnB,MAAMK,EAASX,KAAKY,UAAUZ,KAAKU,UAAWV,KAAKa,YAOnD,IANAb,KAAKU,UAAUL,EAAIL,KAAKU,UAAUJ,EAAIK,EACtCX,KAAKU,UAAUF,aAAc,EAG7BR,KAAKc,QAAU,CAACd,KAAKU,WAEdV,KAAKc,QAAQC,OAAS,GAAG,CAE5Bf,KAAKgB,gBAAgBhB,KAAKc,SAC1B,IAAIG,EAAUjB,KAAKc,QAAQI,QAG3BD,EAAQT,aAAc,EAEtB,IAAIW,EAAenB,KAAKoB,aAAaH,EAAQI,IAAKJ,EAAQK,KAG1D,GAAIL,IAAYjB,KAAKa,WAAY,MAG7BI,EAAQM,SAAWN,EAAQV,aAG/BU,EAAQV,YAAa,EAGrBP,KAAKwB,MAAMC,KAAK,CACZC,KAAM,UACNC,QAAS,CAACR,KAIdnB,KAAK4B,gBAAgBX,GACxB,CAgBD,OAdAjB,KAAKwB,MAAMC,KAAK,CACZC,KAAM,SACNC,QAAS3B,KAAK6B,iBAIlB7B,KAAKH,MAAMI,SAASC,IAChBA,EAAKC,SAAWC,IAChBF,EAAKG,EAAID,IACTF,EAAKI,EAAIF,IACTF,EAAKK,YAAa,EAClBL,EAAKM,aAAc,EACnBN,EAAKO,KAAO,IAAZ,IAEGT,KAAKwB,KACf,CAEDZ,SAAAA,CAAUkB,EAAOC,GAGb,OAA2B,MADDC,KAAKC,IAAIH,EAAMT,IAAMU,EAAMV,KAAOW,KAAKC,IAAIH,EAAMR,IAAMS,EAAMT,KAE1F,CAEDO,YAAAA,CAAaZ,EAAUjB,KAAKa,YACxB,MAAMqB,EAAe,GACrB,IAAIC,EAAOlB,EAEX,KAAgB,OAATkB,GACHD,EAAaE,QAAQpC,KAAKoB,aAAae,EAAKd,IAAKc,EAAKb,MACtDa,EAAOA,EAAK1B,KAEhB,OAAOyB,CACV,CAEDN,eAAAA,CAAgB1B,GACZ,MAAMmC,EAAYrC,KAAKsC,aAAapC,GAEpC,IAAK,MAAMqC,KAAYF,EAAW,CAE9B,GAAIE,EAAShB,SAAWgB,EAAShC,WAAY,SAG7C,MAAMiC,EAAatC,EAAKI,EAAI,EAG5B,GAAIkC,EAAaD,EAASjC,EAAG,CACzB,MAAMmC,EAAQzC,KAAKoB,aAAamB,EAASlB,IAAKkB,EAASjB,KAGvDiB,EAAS9B,KAAOP,EAChBqC,EAASjC,EAAIkC,EACbD,EAASpC,SAAWqC,EACpBD,EAASlC,EAAImC,EAAaxC,KAAKY,UAAU2B,EAAUvC,KAAKa,YAGnD0B,EAAS/B,cACV+B,EAAS/B,aAAc,EACvBR,KAAKc,QAAQW,KAAKc,IAGtBvC,KAAKwB,MAAMC,KAAK,CAAEC,KAAM,UAAWC,QAAS,CAACc,IAChD,CACJ,CACJ,CAEDH,YAAAA,CAAapC,GAET,MAAMmC,EAAY,IACZhB,IAAEA,EAAFC,IAAOA,GAAQpB,GACfwC,KAAEA,EAAFC,KAAQA,GAAS3C,KAWvB,OATIqB,EAAM,GACNgB,EAAUZ,KAAKzB,KAAKH,MAAMG,KAAKoB,aAAaC,EAAM,EAAGC,KACrDD,EAAMqB,EAAO,GACbL,EAAUZ,KAAKzB,KAAKH,MAAMG,KAAKoB,aAAaC,EAAM,EAAGC,KACrDA,EAAM,GACNe,EAAUZ,KAAKzB,KAAKH,MAAMG,KAAKoB,aAAaC,EAAKC,EAAM,KACvDA,EAAMqB,EAAO,GACbN,EAAUZ,KAAKzB,KAAKH,MAAMG,KAAKoB,aAAaC,EAAKC,EAAM,KAEpDe,CACV,CAEDrB,eAAAA,CAAgBnB,GACZA,EAAM+C,MAAK,CAACd,EAAOC,KAEf,GAAID,EAAMzB,IAAM0B,EAAM1B,EAClB,OAAOyB,EAAMzB,EAAI0B,EAAM1B,EAK3B,OAFWL,KAAKY,UAAUkB,EAAO9B,KAAKa,YAC3Bb,KAAKY,UAAUmB,EAAO/B,KAAKa,WACtC,GAEP","file":"AStar.js","sourcesContent":["import Node from \"../node/Node.js\";\nimport Algorithm from \"./Algorithm.js\";\n\nexport default class Astar extends Algorithm {\n    /**@param {Node[]} nodes  */\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        // Initialize all nodes\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.g = Infinity;\n            node.is_visited = false;\n            node.in_open_set = false;\n            node.prev = null;\n        });\n\n        // Initialize start node\n        this.startNode.distance = 0;\n        this.startNode.g = 0;\n        const startH = this.heuristic(this.startNode, this.finishNode);\n        this.startNode.f = this.startNode.g + startH;\n        this.startNode.in_open_set = true;\n\n        // Open set contains only unvisited nodes to be evaluated\n        this.openSet = [this.startNode];\n\n        while (this.openSet.length > 0) {\n            // Find node with lowest f score\n            this.sortByHeuristic(this.openSet);\n            let current = this.openSet.shift();\n            \n            // Remove from open set\n            current.in_open_set = false;\n            \n            let currentIndex = this.get_1d_index(current.row, current.col);\n            \n            // Check if we reached the goal\n            if (current === this.finishNode) break;\n            \n            // Skip walls and already visited nodes\n            if (current.is_wall || current.is_visited) continue;\n            \n            // Add to closed set (mark as visited)\n            current.is_visited = true;\n\n            // Add visualization step\n            this.steps.push({\n                type: \"visited\",\n                indices: [currentIndex],\n            });\n\n            // Update neighbors\n            this.updateNeighbors(current);\n        }\n\n        this.steps.push({\n            type: \"finish\",\n            indices: this.aStarGetPath(),\n        });\n\n        // Clean up node properties\n        this.nodes.forEach((node) => {\n            node.distance = Infinity;\n            node.f = Infinity;\n            node.g = Infinity;\n            node.is_visited = false;\n            node.in_open_set = false;\n            node.prev = null;\n        });\n        return this.steps;\n    }\n\n    heuristic(node1, node2) {\n        // Manhattan distance heuristic with slight emphasis to show A* behavior\n        const manhattanDistance = Math.abs(node1.row - node2.row) + Math.abs(node1.col - node2.col);\n        return manhattanDistance * 1.05; // Very slight emphasis on heuristic to make A* more goal-directed\n    }\n\n    aStarGetPath(current = this.finishNode) {\n        const shortestPath = [];\n        let curr = current;\n\n        while (curr !== null) {\n            shortestPath.unshift(this.get_1d_index(curr.row, curr.col));\n            curr = curr.prev;\n        }\n        return shortestPath;\n    }\n\n    updateNeighbors(node) {\n        const neighbors = this.getNeighbors(node);\n\n        for (const neighbor of neighbors) {\n            // Skip walls and visited nodes\n            if (neighbor.is_wall || neighbor.is_visited) continue;\n            \n            // Calculate tentative g score\n            const tentativeG = node.g + 1;\n            \n            // If this path to neighbor is better than any previous one\n            if (tentativeG < neighbor.g) {\n                const index = this.get_1d_index(neighbor.row, neighbor.col);\n                \n                // Update neighbor\n                neighbor.prev = node;\n                neighbor.g = tentativeG;\n                neighbor.distance = tentativeG; // Keep for compatibility\n                neighbor.f = tentativeG + this.heuristic(neighbor, this.finishNode);\n\n                // Add to open set if not already there\n                if (!neighbor.in_open_set) {\n                    neighbor.in_open_set = true;\n                    this.openSet.push(neighbor);\n                }\n\n                this.steps.push({ type: \"updated\", indices: [index] });\n            }\n        }\n    }\n\n    getNeighbors(node) {\n        /**@type {Node[]} */\n        const neighbors = [];\n        const { row, col } = node;\n        const { rows, cols } = this;\n\n        if (row > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row - 1, col)]);\n        if (row < rows - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row + 1, col)]);\n        if (col > 0)\n            neighbors.push(this.nodes[this.get_1d_index(row, col - 1)]);\n        if (col < cols - 1)\n            neighbors.push(this.nodes[this.get_1d_index(row, col + 1)]);\n\n        return neighbors; // Return all neighbors, filtering happens in updateNeighbors\n    }\n\n    sortByHeuristic(nodes) {\n        nodes.sort((node1, node2) => {\n            // Primary sort by f-score (g + h)\n            if (node1.f !== node2.f) {\n                return node1.f - node2.f;\n            }\n            // Tie-breaker: prefer nodes closer to goal (lower h)\n            const h1 = this.heuristic(node1, this.finishNode);\n            const h2 = this.heuristic(node2, this.finishNode);\n            return h1 - h2;\n        });\n    }\n}\n"]}