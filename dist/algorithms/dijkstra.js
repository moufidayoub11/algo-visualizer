import Node from"../node/Node.js";import Algorithm from"./Algorithm.js";export default class Dijkstra extends Algorithm{constructor(t){super(t)}solve(){for(let t of this.nodes)t.distance=1/0,t.is_visited=!1,t.prev=null;this.startNode.distance=0;let t=this.nodes.slice();for(;t.length;){this.sortByDistance(t);let s=t.shift(),i=this.get_1d_index(s.row,s.col);if(!s.is_wall){if(s.distance==1/0)break;if(s.is_visited=!0,this.steps.push({type:"visited",indices:[i]}),s==this.finishNode)break;this.updateNeighbors(s,this.nodes)}}this.steps.push({type:"finish",indices:this.dijkstraGetPath()});for(let t of this.nodes)t.distance=1/0,t.is_visited=!1,t.prev=null;return this.steps}dijkstraGetPath(t=this.finishNode){const s=[];let i=t;for(;null!==i;)s.unshift(this.get_1d_index(i.row,i.col)),i=i.prev;return s}updateNeighbors(t,s){let i=this.getNeighbors(t,s);for(let s of i){if(t.distance+1<s.distance){const i=this.get_1d_index(s.row,s.col);s.distance=t.distance+1,s.prev=t,this.steps.push({type:"updated",indices:[i]})}}}getNeighbors(t,s){const i=[];let e=t.row,d=t.col,o=this.rows,h=this.cols;return e>0&&i.push(s[this.get_1d_index(e-1,d)]),e<o-1&&i.push(s[this.get_1d_index(e+1,d)]),d>0&&i.push(s[this.get_1d_index(e,d-1)]),d<h-1&&i.push(s[this.get_1d_index(e,d+1)]),i.filter((t=>!t.is_visited&&!t.is_wall))}sortByDistance(t){t.sort(((t,s)=>t.distance-s.distance))}}
//# sourceMappingURL=dijkstra.js.map