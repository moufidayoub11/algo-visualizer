{"version":3,"sources":["WallGenerator.js"],"names":["WallGenerator","constructor","nodes","rows","cols","this","generateWalls","algorithm","generateRecursiveDivision","generateRecursiveBacktracking","generateKruskalsMaze","generateRandomWalls","walls","Set","addBorderWalls","divideArea","x1","y1","x2","y2","width","height","Math","random","possibleYs","y","push","wallY","floor","length","x","idx","is_start","is_finish","add","possibleXs","passageX","delete","wallX","passageY","r","c","visited","Array","from","fill","stack","sr","sc","neighbors","getUnvisitedNeighbors","row","nr","col","nc","pop","sets","setId","edges","r1","c1","r2","c2","wr","wc","sort","e","setA","setB","dist","reduce","arr","dr","dc"],"mappings":"eAAe,MAAMA,cACnBC,WAAAA,CAAYC,EAAOC,EAAMC,GACvBC,KAAKH,MAAQA,EACbG,KAAKF,KAAOA,EACZE,KAAKD,KAAOA,CACb,CAEDE,aAAAA,CAAcC,GACZ,OAAQA,GACN,IAAK,qBACH,OAAOF,KAAKG,4BACd,IAAK,yBACH,OAAOH,KAAKI,gCACd,IAAK,WACH,OAAOJ,KAAKK,uBACd,QACE,OAAOL,KAAKM,sBAEjB,CAEDH,yBAAAA,GACE,MAAMI,EAAQ,IAAIC,IAGlB,OAFAR,KAAKS,eAAeF,GACpBP,KAAKU,WAAW,EAAG,EAAGV,KAAKD,KAAO,EAAGC,KAAKF,KAAO,EAAGS,GAC7C,IAAIA,EACZ,CAEDG,UAAAA,CAAWC,EAAIC,EAAIC,EAAIC,EAAIP,GACzB,MAAMQ,EAAQF,EAAKF,EAAK,EAClBK,EAASF,EAAKF,EAAK,EACzB,GAAIG,EAAQ,GAAKC,EAAS,EAAG,OAI7B,GADmBA,EAASD,GAAUC,IAAWD,GAASE,KAAKC,SAAW,GAC1D,CAEd,MAAMC,EAAa,GACnB,IAAK,IAAIC,EAAIR,EAAK,EAAGQ,GAAKN,EAAK,EAAGM,IAASA,EAAI,GAAM,GAAGD,EAAWE,KAAKD,GACxE,MAAME,EAAQH,EAAWF,KAAKM,MAAMN,KAAKC,SAAWC,EAAWK,SAG/D,IAAK,IAAIC,EAAId,EAAIc,GAAKZ,EAAIY,IAAK,CAC7B,MAAMC,EAAMJ,EAAQtB,KAAKD,KAAO0B,EAC3BzB,KAAKH,MAAM6B,GAAKC,UAAa3B,KAAKH,MAAM6B,GAAKE,WAAWrB,EAAMsB,IAAIH,EACxE,CAED,MAAMI,EAAa,GACnB,IAAK,IAAIL,EAAId,EAAIc,GAAKZ,EAAIY,IAASA,EAAI,GAAM,GAAGK,EAAWT,KAAKI,GAChE,MAAMM,EAAWD,EAAWb,KAAKM,MAAMN,KAAKC,SAAWY,EAAWN,SAClEjB,EAAMyB,OAAOV,EAAQtB,KAAKD,KAAOgC,GAEjC/B,KAAKU,WAAWC,EAAIC,EAAIC,EAAIS,EAAQ,EAAGf,GACvCP,KAAKU,WAAWC,EAAIW,EAAQ,EAAGT,EAAIC,EAAIP,EACxC,KAAM,CAEL,MAAMuB,EAAa,GACnB,IAAK,IAAIL,EAAId,EAAK,EAAGc,GAAKZ,EAAK,EAAGY,IAASA,EAAI,GAAM,GAAGK,EAAWT,KAAKI,GACxE,MAAMQ,EAAQH,EAAWb,KAAKM,MAAMN,KAAKC,SAAWY,EAAWN,SAG/D,IAAK,IAAIJ,EAAIR,EAAIQ,GAAKN,EAAIM,IAAK,CAC7B,MAAMM,EAAMN,EAAIpB,KAAKD,KAAOkC,EACvBjC,KAAKH,MAAM6B,GAAKC,UAAa3B,KAAKH,MAAM6B,GAAKE,WAAWrB,EAAMsB,IAAIH,EACxE,CAED,MAAMP,EAAa,GACnB,IAAK,IAAIC,EAAIR,EAAIQ,GAAKN,EAAIM,IAASA,EAAI,GAAM,GAAGD,EAAWE,KAAKD,GAChE,MAAMc,EAAWf,EAAWF,KAAKM,MAAMN,KAAKC,SAAWC,EAAWK,SAClEjB,EAAMyB,OAAOE,EAAWlC,KAAKD,KAAOkC,GAEpCjC,KAAKU,WAAWC,EAAIC,EAAIqB,EAAQ,EAAGnB,EAAIP,GACvCP,KAAKU,WAAWuB,EAAQ,EAAGrB,EAAIC,EAAIC,EAAIP,EACxC,CACF,CAEDH,6BAAAA,GACE,MAAMG,EAAQ,IAAIC,IAClBR,KAAKS,eAAeF,GAEpB,IAAK,IAAI4B,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,IAAK,CACtC,MAAMV,EAAMS,EAAInC,KAAKD,KAAOqC,EACvBpC,KAAKH,MAAM6B,GAAKC,UAAa3B,KAAKH,MAAM6B,GAAKE,WAAWrB,EAAMsB,IAAIH,EACxE,CAEH,MAAMW,EAAUC,MAAMC,KAAK,CAAEf,OAAQxB,KAAKF,OAAQ,IAAMwC,MAAMtC,KAAKD,MAAMyC,MAAK,KACxEC,EAAQ,GAEd,IAAIC,EAAK,EAAI,EAAIzB,KAAKM,MAAMN,KAAKC,WAAalB,KAAKF,KAAO,GAAK,IAC3D6C,EAAK,EAAI,EAAI1B,KAAKM,MAAMN,KAAKC,WAAalB,KAAKD,KAAO,GAAK,IAC/D,GAAIC,KAAKH,MAAM6C,EAAK1C,KAAKD,KAAO4C,GAAIhB,UAAY3B,KAAKH,MAAM6C,EAAK1C,KAAKD,KAAO4C,GAAIf,UAC9E,IAAK,IAAIO,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,GAAK,EACtC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,GAAK,EACtC,IAAKpC,KAAKH,MAAMsC,EAAInC,KAAKD,KAAOqC,GAAGT,WAAa3B,KAAKH,MAAMsC,EAAInC,KAAKD,KAAOqC,GAAGR,UAAW,CACvFc,EAAKP,EAAGQ,EAAKP,EAAG,KACjB,CAMP,IAJAC,EAAQK,GAAIC,IAAM,EAClBpC,EAAMyB,OAAOU,EAAK1C,KAAKD,KAAO4C,GAC9BF,EAAMpB,KAAK,CAAEc,EAAGO,EAAIN,EAAGO,IAEhBF,EAAMjB,QAAQ,CACnB,MAAMW,EAAEA,EAAFC,EAAKA,GAAMK,EAAMA,EAAMjB,OAAS,GAChCoB,EAAY5C,KAAK6C,sBAAsBV,EAAGC,EAAGC,EAAS,GAC5D,GAAIO,EAAUpB,OAAQ,CACpB,MAAQsB,IAAKC,EAAIC,IAAKC,GAAOL,EAAU3B,KAAKM,MAAMN,KAAKC,SAAW0B,EAAUpB,SAC5Ea,EAAQU,GAAIE,IAAM,EAElB1C,EAAMyB,OAAOe,EAAK/C,KAAKD,KAAOkD,GAC9B1C,EAAMyB,QAAQG,EAAIY,GAAM,EAAI/C,KAAKD,MAAQqC,EAAIa,GAAM,GACnDR,EAAMpB,KAAK,CAAEc,EAAGY,EAAIX,EAAGa,GACxB,MAAMR,EAAMS,KACd,CACD,MAAO,IAAI3C,EACZ,CAEDF,oBAAAA,GACE,MAAME,EAAQ,IAAIC,IAClBR,KAAKS,eAAeF,GACpB,IAAK,IAAI4B,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,IAAK,CACtC,MAAMV,EAAMS,EAAInC,KAAKD,KAAOqC,EACvBpC,KAAKH,MAAM6B,GAAKC,UAAa3B,KAAKH,MAAM6B,GAAKE,WAAWrB,EAAMsB,IAAIH,EACxE,CAEH,MAAMyB,EAAOb,MAAMC,KAAK,CAAEf,OAAQxB,KAAKF,OAAQ,IAAMwC,MAAMtC,KAAKD,MAAMyC,KAAK,QAC3E,IAAIY,EAAQ,EACZ,IAAK,IAAIjB,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,GAAK,EACtC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,GAAK,EACtCe,EAAKhB,GAAGC,GAAKgB,IACb7C,EAAMyB,OAAOG,EAAInC,KAAKD,KAAOqC,GAGjC,MAAMiB,EAAQ,GACd,IAAK,IAAIlB,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,GAAK,EACtC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,GAAK,EAClCA,EAAI,EAAIpC,KAAKD,KAAO,GAAGsD,EAAMhC,KAAK,CAAEiC,GAAInB,EAAGoB,GAAInB,EAAGoB,GAAIrB,EAAGsB,GAAIrB,EAAI,EAAGsB,GAAIvB,EAAGwB,GAAIvB,EAAI,IACnFD,EAAI,EAAInC,KAAKF,KAAO,GAAGuD,EAAMhC,KAAK,CAAEiC,GAAInB,EAAGoB,GAAInB,EAAGoB,GAAIrB,EAAI,EAAGsB,GAAIrB,EAAGsB,GAAIvB,EAAI,EAAGwB,GAAIvB,IAE3FiB,EAAMO,MAAK,IAAM3C,KAAKC,SAAW,KAEjC,IAAK,MAAM2C,KAAKR,EAAO,CACrB,MAAMS,EAAOX,EAAKU,EAAEP,IAAIO,EAAEN,IACpBQ,EAAOZ,EAAKU,EAAEL,IAAIK,EAAEJ,IAC1B,GAAIK,IAASC,EAAM,CACjBxD,EAAMyB,OAAO6B,EAAEH,GAAK1D,KAAKD,KAAO8D,EAAEF,IAClC,IAAK,IAAIxB,EAAI,EAAGA,EAAInC,KAAKF,KAAO,EAAGqC,IACjC,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAO,EAAGqC,IAC7Be,EAAKhB,GAAGC,KAAO2B,IAAMZ,EAAKhB,GAAGC,GAAK0B,EAC3C,CACF,CAED,MAAO,IAAIvD,EACZ,CAEDE,cAAAA,CAAeF,GACb,IAAK,IAAI4B,EAAI,EAAGA,EAAInC,KAAKF,KAAMqC,IAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIpC,KAAKD,KAAMqC,IAC7B,GAAU,IAAND,GAAWA,IAAMnC,KAAKF,KAAO,GAAW,IAANsC,GAAWA,IAAMpC,KAAKD,KAAO,EAAG,CACpE,MAAM2B,EAAMS,EAAInC,KAAKD,KAAOqC,EACvBpC,KAAKH,MAAM6B,GAAKC,UAAa3B,KAAKH,MAAM6B,GAAKE,WAAWrB,EAAMsB,IAAIH,EACxE,CAEN,CAEDmB,qBAAAA,CAAsBV,EAAGC,EAAGC,EAAS2B,GAEnC,MADa,CAAC,EAAEA,EAAK,GAAG,CAACA,EAAK,GAAG,CAAC,GAAGA,GAAM,CAAC,EAAEA,IAClCC,QAAO,CAACC,GAAKC,EAAGC,MAC1B,MAAMrB,EAAKZ,EAAEgC,EAAIlB,EAAKb,EAAEgC,EAClB1C,EAAMqB,EAAG/C,KAAKD,KAAKkD,EAIzB,OAHIF,EAAG,GAAKA,EAAG/C,KAAKF,KAAK,GAAKmD,EAAG,GAAKA,EAAGjD,KAAKD,KAAK,IAAMsC,EAAQU,GAAIE,KAC/DjD,KAAKH,MAAM6B,GAAKC,WAAa3B,KAAKH,MAAM6B,GAAKE,WACjDsC,EAAI7C,KAAK,CAACyB,IAAIC,EAAGC,IAAIC,IAChBiB,CAAP,GACC,GACJ","file":"WallGenerator.js","sourcesContent":["export default class WallGenerator {\n  constructor(nodes, rows, cols) {\n    this.nodes = nodes;\n    this.rows = rows;\n    this.cols = cols;\n  }\n\n  generateWalls(algorithm) {\n    switch (algorithm) {\n      case \"recursive-division\":\n        return this.generateRecursiveDivision();\n      case \"recursive-backtracking\":\n        return this.generateRecursiveBacktracking();\n      case \"kruskals\":\n        return this.generateKruskalsMaze();\n      default:\n        return this.generateRandomWalls();\n    }\n  }\n  \n  generateRecursiveDivision() {\n    const walls = new Set();\n    this.addBorderWalls(walls);\n    this.divideArea(1, 1, this.cols - 2, this.rows - 2, walls);\n    return [...walls];\n  }\n\n  divideArea(x1, y1, x2, y2, walls) {\n    const width = x2 - x1 + 1;\n    const height = y2 - y1 + 1;\n    if (width < 3 || height < 3) return;\n\n    // choose orientation\n    const horizontal = height > width || (height === width && Math.random() > 0.5);\n    if (horizontal) {\n      // pick an even row for the wall\n      const possibleYs = [];\n      for (let y = y1 + 1; y <= y2 - 1; y++) if (y % 2 === 0) possibleYs.push(y);\n      const wallY = possibleYs[Math.floor(Math.random() * possibleYs.length)];\n\n      // draw horizontal wall\n      for (let x = x1; x <= x2; x++) {\n        const idx = wallY * this.cols + x;\n        if (!this.nodes[idx].is_start && !this.nodes[idx].is_finish) walls.add(idx);\n      }\n      // carve one passage at odd column\n      const possibleXs = [];\n      for (let x = x1; x <= x2; x++) if (x % 2 === 1) possibleXs.push(x);\n      const passageX = possibleXs[Math.floor(Math.random() * possibleXs.length)];\n      walls.delete(wallY * this.cols + passageX);\n\n      this.divideArea(x1, y1, x2, wallY - 1, walls);\n      this.divideArea(x1, wallY + 1, x2, y2, walls);\n    } else {\n      // pick an even column for the wall\n      const possibleXs = [];\n      for (let x = x1 + 1; x <= x2 - 1; x++) if (x % 2 === 0) possibleXs.push(x);\n      const wallX = possibleXs[Math.floor(Math.random() * possibleXs.length)];\n\n      // draw vertical wall\n      for (let y = y1; y <= y2; y++) {\n        const idx = y * this.cols + wallX;\n        if (!this.nodes[idx].is_start && !this.nodes[idx].is_finish) walls.add(idx);\n      }\n      // carve one passage at odd row\n      const possibleYs = [];\n      for (let y = y1; y <= y2; y++) if (y % 2 === 1) possibleYs.push(y);\n      const passageY = possibleYs[Math.floor(Math.random() * possibleYs.length)];\n      walls.delete(passageY * this.cols + wallX);\n\n      this.divideArea(x1, y1, wallX - 1, y2, walls);\n      this.divideArea(wallX + 1, y1, x2, y2, walls);\n    }\n  }\n\n  generateRecursiveBacktracking() {\n    const walls = new Set();\n    this.addBorderWalls(walls);\n    // start with every inner cell as wall\n    for (let r = 1; r < this.rows - 1; r++)\n      for (let c = 1; c < this.cols - 1; c++) {\n        const idx = r * this.cols + c;\n        if (!this.nodes[idx].is_start && !this.nodes[idx].is_finish) walls.add(idx);\n      }\n\n    const visited = Array.from({ length: this.rows }, () => Array(this.cols).fill(false));\n    const stack = [];\n    // pick random odd start\n    let sr = 1 + 2 * Math.floor(Math.random() * ((this.rows - 2) / 2));\n    let sc = 1 + 2 * Math.floor(Math.random() * ((this.cols - 2) / 2));\n    if (this.nodes[sr * this.cols + sc].is_start || this.nodes[sr * this.cols + sc].is_finish) {\n      for (let r = 1; r < this.rows - 1; r += 2)\n        for (let c = 1; c < this.cols - 1; c += 2)\n          if (!this.nodes[r * this.cols + c].is_start && !this.nodes[r * this.cols + c].is_finish) {\n            sr = r; sc = c; break;\n          }\n    }\n    visited[sr][sc] = true;\n    walls.delete(sr * this.cols + sc);\n    stack.push({ r: sr, c: sc });\n\n    while (stack.length) {\n      const { r, c } = stack[stack.length - 1];\n      const neighbors = this.getUnvisitedNeighbors(r, c, visited, 2);\n      if (neighbors.length) {\n        const { row: nr, col: nc } = neighbors[Math.floor(Math.random() * neighbors.length)];\n        visited[nr][nc] = true;\n        // remove wall between\n        walls.delete(nr * this.cols + nc);\n        walls.delete((r + nr) / 2 * this.cols + (c + nc) / 2);\n        stack.push({ r: nr, c: nc });\n      } else stack.pop();\n    }\n    return [...walls];\n  }\n\n  generateKruskalsMaze() {\n    const walls = new Set();\n    this.addBorderWalls(walls);\n    for (let r = 1; r < this.rows - 1; r++)\n      for (let c = 1; c < this.cols - 1; c++) {\n        const idx = r * this.cols + c;\n        if (!this.nodes[idx].is_start && !this.nodes[idx].is_finish) walls.add(idx);\n      }\n\n    const sets = Array.from({ length: this.rows }, () => Array(this.cols).fill(null));\n    let setId = 0;\n    for (let r = 1; r < this.rows - 1; r += 2)\n      for (let c = 1; c < this.cols - 1; c += 2) {\n        sets[r][c] = setId++;\n        walls.delete(r * this.cols + c);\n      }\n\n    const edges = [];\n    for (let r = 1; r < this.rows - 1; r += 2)\n      for (let c = 1; c < this.cols - 1; c += 2) {\n        if (c + 2 < this.cols - 1) edges.push({ r1: r, c1: c, r2: r, c2: c + 2, wr: r, wc: c + 1 });\n        if (r + 2 < this.rows - 1) edges.push({ r1: r, c1: c, r2: r + 2, c2: c, wr: r + 1, wc: c });\n      }\n    edges.sort(() => Math.random() - 0.5);\n\n    for (const e of edges) {\n      const setA = sets[e.r1][e.c1];\n      const setB = sets[e.r2][e.c2];\n      if (setA !== setB) {\n        walls.delete(e.wr * this.cols + e.wc);\n        for (let r = 1; r < this.rows - 1; r++)\n          for (let c = 1; c < this.cols - 1; c++)\n            if (sets[r][c] === setB) sets[r][c] = setA;\n      }\n    }\n\n    return [...walls];\n  }\n\n  addBorderWalls(walls) {\n    for (let r = 0; r < this.rows; r++)\n      for (let c = 0; c < this.cols; c++) {\n        if (r === 0 || r === this.rows - 1 || c === 0 || c === this.cols - 1) {\n          const idx = r * this.cols + c;\n          if (!this.nodes[idx].is_start && !this.nodes[idx].is_finish) walls.add(idx);\n        }\n      }\n  }\n\n  getUnvisitedNeighbors(r, c, visited, dist) {\n    const dirs = [[-dist,0],[dist,0],[0,-dist],[0,dist]];\n    return dirs.reduce((arr,[dr,dc]) => {\n      const nr = r+dr, nc = c+dc;\n      const idx = nr*this.cols+nc;\n      if (nr>0 && nr<this.rows-1 && nc>0 && nc<this.cols-1 && !visited[nr][nc]\n        && !this.nodes[idx].is_start && !this.nodes[idx].is_finish)\n        arr.push({row:nr,col:nc});\n      return arr;\n    }, []);\n  }\n}\n"]}