export default class WallGenerator{constructor(s,t,e){this.nodes=s,this.rows=t,this.cols=e}generateWalls(s){switch(s){case"recursive-division":return this.generateRecursiveDivision();case"recursive-backtracking":return this.generateRecursiveBacktracking();case"kruskals":return this.generateKruskalsMaze();default:return this.generateRandomWalls()}}generateRecursiveDivision(){const s=new Set;return this.addBorderWalls(s),this.divideArea(1,1,this.cols-2,this.rows-2,s),[...s]}divideArea(s,t,e,o,i){const r=e-s+1,h=o-t+1;if(r<3||h<3)return;if(h>r||h===r&&Math.random()>.5){const r=[];for(let s=t+1;s<=o-1;s++)s%2==0&&r.push(s);const h=r[Math.floor(Math.random()*r.length)];for(let t=s;t<=e;t++){const s=h*this.cols+t;this.nodes[s].is_start||this.nodes[s].is_finish||i.add(s)}const l=[];for(let t=s;t<=e;t++)t%2==1&&l.push(t);const n=l[Math.floor(Math.random()*l.length)];i.delete(h*this.cols+n),this.divideArea(s,t,e,h-1,i),this.divideArea(s,h+1,e,o,i)}else{const r=[];for(let t=s+1;t<=e-1;t++)t%2==0&&r.push(t);const h=r[Math.floor(Math.random()*r.length)];for(let s=t;s<=o;s++){const t=s*this.cols+h;this.nodes[t].is_start||this.nodes[t].is_finish||i.add(t)}const l=[];for(let s=t;s<=o;s++)s%2==1&&l.push(s);const n=l[Math.floor(Math.random()*l.length)];i.delete(n*this.cols+h),this.divideArea(s,t,h-1,o,i),this.divideArea(h+1,t,e,o,i)}}generateRecursiveBacktracking(){const s=new Set;this.addBorderWalls(s);for(let t=1;t<this.rows-1;t++)for(let e=1;e<this.cols-1;e++){const o=t*this.cols+e;this.nodes[o].is_start||this.nodes[o].is_finish||s.add(o)}const t=Array.from({length:this.rows},(()=>Array(this.cols).fill(!1))),e=[];let o=1+2*Math.floor(Math.random()*((this.rows-2)/2)),i=1+2*Math.floor(Math.random()*((this.cols-2)/2));if(this.nodes[o*this.cols+i].is_start||this.nodes[o*this.cols+i].is_finish)for(let s=1;s<this.rows-1;s+=2)for(let t=1;t<this.cols-1;t+=2)if(!this.nodes[s*this.cols+t].is_start&&!this.nodes[s*this.cols+t].is_finish){o=s,i=t;break}for(t[o][i]=!0,s.delete(o*this.cols+i),e.push({r:o,c:i});e.length;){const{r:o,c:i}=e[e.length-1],r=this.getUnvisitedNeighbors(o,i,t,2);if(r.length){const{row:h,col:l}=r[Math.floor(Math.random()*r.length)];t[h][l]=!0,s.delete(h*this.cols+l),s.delete((o+h)/2*this.cols+(i+l)/2),e.push({r:h,c:l})}else e.pop()}return[...s]}generateKruskalsMaze(){const s=new Set;this.addBorderWalls(s);for(let t=1;t<this.rows-1;t++)for(let e=1;e<this.cols-1;e++){const o=t*this.cols+e;this.nodes[o].is_start||this.nodes[o].is_finish||s.add(o)}const t=Array.from({length:this.rows},(()=>Array(this.cols).fill(null)));let e=0;for(let o=1;o<this.rows-1;o+=2)for(let i=1;i<this.cols-1;i+=2)t[o][i]=e++,s.delete(o*this.cols+i);const o=[];for(let s=1;s<this.rows-1;s+=2)for(let t=1;t<this.cols-1;t+=2)t+2<this.cols-1&&o.push({r1:s,c1:t,r2:s,c2:t+2,wr:s,wc:t+1}),s+2<this.rows-1&&o.push({r1:s,c1:t,r2:s+2,c2:t,wr:s+1,wc:t});o.sort((()=>Math.random()-.5));for(const e of o){const o=t[e.r1][e.c1],i=t[e.r2][e.c2];if(o!==i){s.delete(e.wr*this.cols+e.wc);for(let s=1;s<this.rows-1;s++)for(let e=1;e<this.cols-1;e++)t[s][e]===i&&(t[s][e]=o)}}return[...s]}addBorderWalls(s){for(let t=0;t<this.rows;t++)for(let e=0;e<this.cols;e++)if(0===t||t===this.rows-1||0===e||e===this.cols-1){const o=t*this.cols+e;this.nodes[o].is_start||this.nodes[o].is_finish||s.add(o)}}getUnvisitedNeighbors(s,t,e,o){return[[-o,0],[o,0],[0,-o],[0,o]].reduce(((o,[i,r])=>{const h=s+i,l=t+r,n=h*this.cols+l;return h>0&&h<this.rows-1&&l>0&&l<this.cols-1&&!e[h][l]&&!this.nodes[n].is_start&&!this.nodes[n].is_finish&&o.push({row:h,col:l}),o}),[])}}
//# sourceMappingURL=WallGenerator.js.map