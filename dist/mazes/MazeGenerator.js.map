{"version":3,"sources":["MazeGenerator.js"],"names":["StateManager","MazeGenerator","constructor","nodes","this","stateManager","steps","rows","getRows","cols","getCols","get_1d_index","row","col","solve","getNeighbors","distance","neighbors","directions","dr","dc","newRow","newCol","push","getWallBetween","cell1","cell2","Math","floor","initializeAllWalls","i","length","node","is_start","is_finish","is_wall","type","indices","initializeAllPaths","addWall","index","removePath","isValidCell","visited","createVisitedArray","Array","fill"],"mappings":"OAAOA,iBAAkB,oCAEV,MAAMC,cACjBC,WAAAA,CAAYC,GACRC,KAAKC,aAAe,IAAIL,aACxBI,KAAKD,MAAQA,EACbC,KAAKE,MAAQ,GACbF,KAAKG,KAAOH,KAAKC,aAAaG,UAC9BJ,KAAKK,KAAOL,KAAKC,aAAaK,UAC9BN,KAAKO,aAAe,CAACC,EAAKC,IAAQD,EAAMR,KAAKK,KAAOI,CACvD,CAEDC,KAAAA,GACI,OAAOV,KAAKE,KACf,CAGDS,YAAAA,CAAaH,EAAKC,EAAKG,EAAW,GAC9B,MAAMC,EAAY,GACZC,EAAa,CACf,EAAEF,EAAU,GACZ,CAACA,EAAU,GACX,CAAC,GAAIA,GACL,CAAC,EAAGA,IAGR,IAAK,MAAOG,EAAIC,KAAOF,EAAY,CAC/B,MAAMG,EAAST,EAAMO,EACfG,EAAST,EAAMO,EAEjBC,GAAU,GAAKA,EAASjB,KAAKG,MAC7Be,GAAU,GAAKA,EAASlB,KAAKK,MAC7BQ,EAAUM,KAAK,CAAEX,IAAKS,EAAQR,IAAKS,GAE1C,CAED,OAAOL,CACV,CAGDO,cAAAA,CAAeC,EAAOC,GAGlB,MAAO,CAAEd,IAFOe,KAAKC,OAAOH,EAAMb,IAAMc,EAAMd,KAAO,GAE9BC,IADPc,KAAKC,OAAOH,EAAMZ,IAAMa,EAAMb,KAAO,GAExD,CAGDgB,kBAAAA,GAEI,IAAK,IAAIC,EAAI,EAAGA,EAAI1B,KAAKD,MAAM4B,OAAQD,IAAK,CACxC,MAAME,EAAO5B,KAAKD,MAAM2B,GACnBE,EAAKC,UAAaD,EAAKE,YACxBF,EAAKG,SAAU,EAEtB,CAGD,IAAK,IAAIL,EAAI,EAAGA,EAAI1B,KAAKD,MAAM4B,OAAQD,IAAK,CACxC,MAAME,EAAO5B,KAAKD,MAAM2B,GACnBE,EAAKC,UAAaD,EAAKE,WACxB9B,KAAKE,MAAMiB,KAAK,CACZa,KAAM,WACNC,QAAS,CAACP,IAGrB,CACJ,CAGDQ,kBAAAA,GACI,IAAK,IAAIR,EAAI,EAAGA,EAAI1B,KAAKD,MAAM4B,OAAQD,IAAK,CACxC,MAAME,EAAO5B,KAAKD,MAAM2B,GACnBE,EAAKC,UAAaD,EAAKE,YACxBF,EAAKG,SAAU,EACf/B,KAAKE,MAAMiB,KAAK,CACZa,KAAM,cACNC,QAAS,CAACP,KAGrB,CACJ,CAGDS,OAAAA,CAAQ3B,EAAKC,GACT,MAAM2B,EAAQpC,KAAKO,aAAaC,EAAKC,GAC/BmB,EAAO5B,KAAKD,MAAMqC,GACnBR,EAAKC,UAAaD,EAAKE,YACxBF,EAAKG,SAAU,EACf/B,KAAKE,MAAMiB,KAAK,CACZa,KAAM,WACNC,QAAS,CAACG,KAGrB,CAGDC,UAAAA,CAAW7B,EAAKC,GACZ,MAAM2B,EAAQpC,KAAKO,aAAaC,EAAKC,GAC/BmB,EAAO5B,KAAKD,MAAMqC,GACnBR,EAAKC,UAAaD,EAAKE,YACxBF,EAAKG,SAAU,EACf/B,KAAKE,MAAMiB,KAAK,CACZa,KAAM,cACNC,QAAS,CAACG,KAGrB,CAGDE,WAAAA,CAAY9B,EAAKC,EAAK8B,GAClB,OAAO/B,GAAO,GAAKA,EAAMR,KAAKG,MACvBM,GAAO,GAAKA,EAAMT,KAAKK,OACtBkC,EAAQ/B,GAAKC,EACxB,CAGD+B,kBAAAA,GACI,MAAMD,EAAU,GAChB,IAAK,IAAIb,EAAI,EAAGA,EAAI1B,KAAKG,KAAMuB,IAC3Ba,EAAQb,GAAK,IAAIe,MAAMzC,KAAKK,MAAMqC,MAAK,GAE3C,OAAOH,CACV","file":"MazeGenerator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\n\nexport default class MazeGenerator {\n    constructor(nodes) {\n        this.stateManager = new StateManager();\n        this.nodes = nodes;\n        this.steps = [];\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n        this.get_1d_index = (row, col) => row * this.cols + col;\n    }\n\n    solve() {\n        return this.steps;\n    }\n\n    // Utility method to get neighbors for maze generation\n    getNeighbors(row, col, distance = 2) {\n        const neighbors = [];\n        const directions = [\n            [-distance, 0], // Up\n            [distance, 0],  // Down\n            [0, -distance], // Left\n            [0, distance]   // Right\n        ];\n\n        for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n            \n            if (newRow >= 0 && newRow < this.rows && \n                newCol >= 0 && newCol < this.cols) {\n                neighbors.push({ row: newRow, col: newCol });\n            }\n        }\n        \n        return neighbors;\n    }\n\n    // Get the wall between two cells\n    getWallBetween(cell1, cell2) {\n        const wallRow = Math.floor((cell1.row + cell2.row) / 2);\n        const wallCol = Math.floor((cell1.col + cell2.col) / 2);\n        return { row: wallRow, col: wallCol };\n    }\n\n    // Initialize grid for maze generation (all walls)\n    initializeAllWalls() {\n        // First set all nodes to walls without animation steps\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (!node.is_start && !node.is_finish) {\n                node.is_wall = true;\n            }\n        }\n        \n        // Then add animation steps to show the wall creation\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (!node.is_start && !node.is_finish) {\n                this.steps.push({ \n                    type: \"add_wall\", \n                    indices: [i] \n                });\n            }\n        }\n    }\n\n    // Clear all walls\n    initializeAllPaths() {\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            if (!node.is_start && !node.is_finish) {\n                node.is_wall = false;\n                this.steps.push({ \n                    type: \"remove_wall\", \n                    indices: [i] \n                });\n            }\n        }\n    }\n\n    // Add a wall\n    addWall(row, col) {\n        const index = this.get_1d_index(row, col);\n        const node = this.nodes[index];\n        if (!node.is_start && !node.is_finish) {\n            node.is_wall = true;\n            this.steps.push({ \n                type: \"add_wall\", \n                indices: [index] \n            });\n        }\n    }\n\n    // Remove a wall (create path)\n    removePath(row, col) {\n        const index = this.get_1d_index(row, col);\n        const node = this.nodes[index];\n        if (!node.is_start && !node.is_finish) {\n            node.is_wall = false;\n            this.steps.push({ \n                type: \"remove_wall\", \n                indices: [index] \n            });\n        }\n    }\n\n    // Check if a cell is valid and unvisited\n    isValidCell(row, col, visited) {\n        return row >= 0 && row < this.rows && \n               col >= 0 && col < this.cols && \n               !visited[row][col];\n    }\n\n    // Create 2D visited array\n    createVisitedArray() {\n        const visited = [];\n        for (let i = 0; i < this.rows; i++) {\n            visited[i] = new Array(this.cols).fill(false);\n        }\n        return visited;\n    }\n}\n"]}