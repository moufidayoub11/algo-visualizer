import StateManager from"../StateManager.js";export default class MazeGenerator{constructor(s){this.stateManager=new StateManager,this.nodes=s,this.steps=[],this.rows=this.stateManager.getRows(),this.cols=this.stateManager.getCols(),this.get_1d_index=(s,t)=>s*this.cols+t}solve(){return this.steps}getNeighbors(s,t,e=2){const i=[],o=[[-e,0],[e,0],[0,-e],[0,e]];for(const[e,l]of o){const o=s+e,r=t+l;o>=0&&o<this.rows&&r>=0&&r<this.cols&&i.push({row:o,col:r})}return i}getWallBetween(s,t){return{row:Math.floor((s.row+t.row)/2),col:Math.floor((s.col+t.col)/2)}}initializeAllWalls(){for(let s=0;s<this.nodes.length;s++){const t=this.nodes[s];t.is_start||t.is_finish||(t.is_wall=!0)}for(let s=0;s<this.nodes.length;s++){const t=this.nodes[s];t.is_start||t.is_finish||this.steps.push({type:"add_wall",indices:[s]})}}initializeAllPaths(){for(let s=0;s<this.nodes.length;s++){const t=this.nodes[s];t.is_start||t.is_finish||(t.is_wall=!1,this.steps.push({type:"remove_wall",indices:[s]}))}}addWall(s,t){const e=this.get_1d_index(s,t),i=this.nodes[e];i.is_start||i.is_finish||(i.is_wall=!0,this.steps.push({type:"add_wall",indices:[e]}))}removePath(s,t){const e=this.get_1d_index(s,t),i=this.nodes[e];i.is_start||i.is_finish||(i.is_wall=!1,this.steps.push({type:"remove_wall",indices:[e]}))}isValidCell(s,t,e){return s>=0&&s<this.rows&&t>=0&&t<this.cols&&!e[s][t]}createVisitedArray(){const s=[];for(let t=0;t<this.rows;t++)s[t]=new Array(this.cols).fill(!1);return s}}
//# sourceMappingURL=MazeGenerator.js.map