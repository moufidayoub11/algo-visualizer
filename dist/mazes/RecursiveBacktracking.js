import MazeGenerator from"./MazeGenerator.js";export default class RecursiveBacktracking extends MazeGenerator{constructor(t){super(t)}solve(){this.initializeAllWalls();const t=this.createVisitedArray();t[1][1]=!0,this.removePath(1,1);const e=[{row:1,col:1}];for(;e.length>0;){const s=e[e.length-1];this.steps.push({type:"current_path",indices:[this.get_1d_index(s.row,s.col)]});const o=this.getUnvisitedNeighbors(s.row,s.col,t);if(o.length>0){const i=o[Math.floor(Math.random()*o.length)];t[i.row][i.col]=!0;const r=this.getWallBetween(s,i);r.row>=0&&r.row<this.rows&&r.col>=0&&r.col<this.cols&&(t[r.row][r.col]=!0,this.removePath(r.row,r.col)),this.removePath(i.row,i.col),e.push(i)}else e.length>1&&this.steps.push({type:"backtrack",indices:[this.get_1d_index(s.row,s.col)]}),e.pop()}return this.steps.push({type:"finish",indices:[]}),this.steps}getUnvisitedNeighbors(t,e,s){const o=[],i=[[-2,0],[2,0],[0,-2],[0,2]];for(const[r,h]of i){const i=t+r,l=e+h;this.isValidMazeCell(i,l,s)&&o.push({row:i,col:l})}return o}isValidMazeCell(t,e,s){return t>=1&&t<this.rows-1&&e>=1&&e<this.cols-1&&!s[t][e]}}
//# sourceMappingURL=RecursiveBacktracking.js.map