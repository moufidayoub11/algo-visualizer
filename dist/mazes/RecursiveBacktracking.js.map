{"version":3,"sources":["RecursiveBacktracking.js"],"names":["MazeGenerator","RecursiveBacktracking","constructor","nodes","super","solve","this","initializeAllWalls","visited","createVisitedArray","removePath","stack","row","col","length","current","steps","push","type","indices","get_1d_index","neighbors","getUnvisitedNeighbors","next","Math","floor","random","wall","getWallBetween","rows","cols","pop","directions","dr","dc","newRow","newCol","isValidMazeCell"],"mappings":"OAAOA,kBAAmB,oCAEX,MAAMC,8BAA8BD,cAC/CE,WAAAA,CAAYC,GACRC,MAAMD,EACT,CAEDE,KAAAA,GAEIC,KAAKC,qBAGL,MAAMC,EAAUF,KAAKG,qBAQrBD,EAJiB,GACA,IAGa,EAC9BF,KAAKI,WALY,EACA,GAOjB,MAAMC,EAAQ,CAAC,CAAEC,IARA,EAQeC,IAPf,IASjB,KAAOF,EAAMG,OAAS,GAAG,CACrB,MAAMC,EAAUJ,EAAMA,EAAMG,OAAS,GAGrCR,KAAKU,MAAMC,KAAK,CACZC,KAAM,eACNC,QAAS,CAACb,KAAKc,aAAaL,EAAQH,IAAKG,EAAQF,QAGrD,MAAMQ,EAAYf,KAAKgB,sBAAsBP,EAAQH,IAAKG,EAAQF,IAAKL,GAEvE,GAAIa,EAAUP,OAAS,EAAG,CAEtB,MAAMS,EAAOF,EAAUG,KAAKC,MAAMD,KAAKE,SAAWL,EAAUP,SAG5DN,EAAQe,EAAKX,KAAKW,EAAKV,MAAO,EAG9B,MAAMc,EAAOrB,KAAKsB,eAAeb,EAASQ,GAGtCI,EAAKf,KAAO,GAAKe,EAAKf,IAAMN,KAAKuB,MAAQF,EAAKd,KAAO,GAAKc,EAAKd,IAAMP,KAAKwB,OAC1EtB,EAAQmB,EAAKf,KAAKe,EAAKd,MAAO,EAC9BP,KAAKI,WAAWiB,EAAKf,IAAKe,EAAKd,MAInCP,KAAKI,WAAWa,EAAKX,IAAKW,EAAKV,KAG/BF,EAAMM,KAAKM,EACd,MAEOZ,EAAMG,OAAS,GACfR,KAAKU,MAAMC,KAAK,CACZC,KAAM,YACNC,QAAS,CAACb,KAAKc,aAAaL,EAAQH,IAAKG,EAAQF,QAGzDF,EAAMoB,KAEb,CAGD,OADAzB,KAAKU,MAAMC,KAAK,CAAEC,KAAM,SAAUC,QAAS,KACpCb,KAAKU,KACf,CAEDM,qBAAAA,CAAsBV,EAAKC,EAAKL,GAC5B,MAAMa,EAAY,GACZW,EAAa,CACf,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,CAAC,GAAI,GACL,CAAC,EAAG,IAGR,IAAK,MAAOC,EAAIC,KAAOF,EAAY,CAC/B,MAAMG,EAASvB,EAAMqB,EACfG,EAASvB,EAAMqB,EAEjB5B,KAAK+B,gBAAgBF,EAAQC,EAAQ5B,IACrCa,EAAUJ,KAAK,CAAEL,IAAKuB,EAAQtB,IAAKuB,GAE1C,CAED,OAAOf,CACV,CAEDgB,eAAAA,CAAgBzB,EAAKC,EAAKL,GACtB,OAAOI,GAAO,GAAKA,EAAMN,KAAKuB,KAAO,GAC9BhB,GAAO,GAAKA,EAAMP,KAAKwB,KAAO,IAC7BtB,EAAQI,GAAKC,EACxB","file":"RecursiveBacktracking.js","sourcesContent":["import MazeGenerator from \"./MazeGenerator.js\";\n\nexport default class RecursiveBacktracking extends MazeGenerator {\n    constructor(nodes) {\n        super(nodes);\n    }\n\n    solve() {\n        // Start with all walls\n        this.initializeAllWalls();\n        \n        // Create visited array\n        const visited = this.createVisitedArray();\n        \n        // Start from a random odd position to ensure proper maze structure\n        // For better visualization, start from top-left area\n        const startRow = 1;\n        const startCol = 1;\n        \n        // Mark starting cell as visited and remove wall\n        visited[startRow][startCol] = true;\n        this.removePath(startRow, startCol);\n        \n        // Use stack for recursive backtracking\n        const stack = [{ row: startRow, col: startCol }];\n        \n        while (stack.length > 0) {\n            const current = stack[stack.length - 1];\n            \n            // Show current position\n            this.steps.push({\n                type: \"current_path\",\n                indices: [this.get_1d_index(current.row, current.col)]\n            });\n            \n            const neighbors = this.getUnvisitedNeighbors(current.row, current.col, visited);\n            \n            if (neighbors.length > 0) {\n                // Choose random neighbor\n                const next = neighbors[Math.floor(Math.random() * neighbors.length)];\n                \n                // Mark as visited\n                visited[next.row][next.col] = true;\n                \n                // Remove wall between current and next (carve path)\n                const wall = this.getWallBetween(current, next);\n                \n                // Remove the wall between cells\n                if (wall.row >= 0 && wall.row < this.rows && wall.col >= 0 && wall.col < this.cols) {\n                    visited[wall.row][wall.col] = true;\n                    this.removePath(wall.row, wall.col);\n                }\n                \n                // Remove the destination cell wall\n                this.removePath(next.row, next.col);\n                \n                // Add to stack\n                stack.push(next);\n            } else {\n                // Backtrack\n                if (stack.length > 1) {\n                    this.steps.push({\n                        type: \"backtrack\",\n                        indices: [this.get_1d_index(current.row, current.col)]\n                    });\n                }\n                stack.pop();\n            }\n        }\n        \n        this.steps.push({ type: \"finish\", indices: [] });\n        return this.steps;\n    }\n    \n    getUnvisitedNeighbors(row, col, visited) {\n        const neighbors = [];\n        const directions = [\n            [-2, 0], // Up (skip one cell to leave wall)\n            [2, 0],  // Down\n            [0, -2], // Left\n            [0, 2]   // Right\n        ];\n        \n        for (const [dr, dc] of directions) {\n            const newRow = row + dr;\n            const newCol = col + dc;\n            \n            if (this.isValidMazeCell(newRow, newCol, visited)) {\n                neighbors.push({ row: newRow, col: newCol });\n            }\n        }\n        \n        return neighbors;\n    }\n    \n    isValidMazeCell(row, col, visited) {\n        return row >= 1 && row < this.rows - 1 && \n               col >= 1 && col < this.cols - 1 && \n               !visited[row][col];\n    }\n}\n"]}