{"version":3,"sources":["GridCreator.js"],"names":["StateManager","Node","Utils","WallGenerator","VISITED_COLOR","CLOSED_COLOR","GridCreator","constructor","this","stateManager","gridElement","getGridElement","nodes","nodesElements","is_mouse_pressed","add_wall","currently_moving","last_hoverd_node","wallGenerationTimeouts","isGeneratingWalls","createGrid","getState","setState","rows","getRows","cols","getCols","createNodes","innerHTML","row","newRow","document","createElement","col","nodeElement","id","className","node","is_start","is_finish","sleep","then","classList","add","push","appendChild","setNodeElements","halfRow","Math","floor","quarterCol","twoThirdCol","i","new_node","setNodes","addRandomWalls","clearGrid","wallAlgorithmSelect","getElementById","selectedAlgorithm","value","wallIndices","generateWalls","animateWallsSequentially","currentIndex","length","config","getWallAnimationConfig","batchEnd","min","batchSize","requestAnimationFrame","index","is_wall","animationFrequency","timeoutId","setTimeout","batchDelay","stopWallGeneration","forEach","clearTimeout","getAnimationSpeed","handleAlgoChange","newAlgo","currentAlgo","clearPaths","startNode","find","finishNode","startNodeEl","finishNodeEl","console","log","remove","bgColor","style","backgroundColor","includes","handleEvents","e","event","preventDefault","target","nodeName","parseInt","split","contains","toggle","lrow","lcol","lnode"],"mappings":"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","file":"GridCreator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\nimport Node from \"../node/Node.js\";\nimport Utils from \"../utils/Utils.js\";\nimport WallGenerator from \"../walls/WallGenerator.js\";\n\nconst VISITED_COLOR = \"rgba(0, 0, 66, 0.75)\";\nconst CLOSED_COLOR = \"rgba(0, 190, 218, 0.75)\";\n\n/**\n * Represents the creation part of the grid\n */\nexport default class GridCreator {\n    constructor() {\n        this.stateManager = new StateManager();\n\n        this.gridElement = this.stateManager.getGridElement();\n\n        /** @type {Node[]} */\n        this.nodes = [];\n        /** @type {HTMLElement[]} */\n        this.nodesElements = [];\n\n        /**\n         * These are for handling the drawing on the grid\n         */\n        /** @type {boolean} */\n        this.is_mouse_pressed = false;\n        /** @type {boolean} */\n        this.add_wall = false;\n        /** @type {string|null} */\n        this.currently_moving = null;\n        /** @type {HTMLElement|null} */\n        this.last_hoverd_node = null;\n\n        // Track wall generation state and timeouts for cancellation\n        this.wallGenerationTimeouts = [];\n        this.isGeneratingWalls = false;\n    }\n\n    /**\n     * Creates the grid\n     */\n    createGrid() {\n        if (this.stateManager.getState()) return;\n        this.stateManager.setState(true);\n        this.rows = this.stateManager.getRows();\n        this.cols = this.stateManager.getCols();\n\n        this.createNodes();\n\n        const gridElement = this.gridElement;\n\n        gridElement.innerHTML = \"\";\n        this.nodesElements = [];\n\n        for (let row = 0; row < this.rows; row++) {\n            const newRow = document.createElement(\"tr\");\n            for (let col = 0; col < this.cols; col++) {\n                const nodeElement = document.createElement(\"td\");\n\n                nodeElement.id = `node-${row}-${col}`;\n                nodeElement.className = \"node\";\n\n                const node = this.nodes[row * this.cols + col];\n                if (node.is_start || node.is_finish) {\n                    Utils.sleep(250).then(() => {\n                        nodeElement.classList.add(\n                            node.is_start ? \"node-start\" : \"node-finish\"\n                        );\n                    });\n                }\n\n                this.nodesElements.push(nodeElement);\n                newRow.appendChild(nodeElement);\n            }\n\n            gridElement.appendChild(newRow);\n        }\n\n        this.stateManager.setState(false);\n        this.stateManager.setNodeElements(this.nodesElements);\n    }\n\n    /**\n     * Initializes nodes\n     */\n    createNodes() {\n        this.nodes = [];\n\n        const halfRow = Math.floor(this.rows / 2);\n        const quarterCol = Math.floor(this.cols / 4);\n        const twoThirdCol = Math.floor((this.cols * 2) / 3);\n        for (let i = 0; i < this.rows * this.cols; i++) {\n            let row = Math.floor(i / this.cols);\n            let col = i % this.cols;\n            let is_start = row === halfRow && col == quarterCol;\n            let is_finish = row === halfRow && col == twoThirdCol;\n            const new_node = new Node(row, col, is_start, is_finish);\n            this.nodes.push(new_node);\n        }\n\n        this.stateManager.setNodes(this.nodes);\n    }\n\n    async addRandomWalls() {\n        this.clearGrid();\n        this.isGeneratingWalls = true;\n        \n        // Get the selected wall algorithm from the dropdown\n        const wallAlgorithmSelect = document.getElementById('wall-algorithm-select');\n        const selectedAlgorithm = wallAlgorithmSelect ? wallAlgorithmSelect.value : 'random';\n        \n        // Generate walls using the selected algorithm\n        const wallGenerator = new WallGenerator(this.nodes, this.rows, this.cols);\n        const wallIndices = wallGenerator.generateWalls(selectedAlgorithm);\n        \n        // Use a simpler approach for wall generation that's more stable with speed changes\n        this.animateWallsSequentially(wallIndices, 0);\n    }\n\n    animateWallsSequentially(wallIndices, currentIndex) {\n        if (!this.isGeneratingWalls || currentIndex >= wallIndices.length) {\n            // Animation completed or cancelled\n            this.isGeneratingWalls = false;\n            this.wallGenerationTimeouts = [];\n            return;\n        }\n        \n        // Get current speed settings for this batch\n        const config = this.getWallAnimationConfig();\n        const batchEnd = Math.min(currentIndex + config.batchSize, wallIndices.length);\n        \n        // Process current batch\n        requestAnimationFrame(() => {\n            if (!this.isGeneratingWalls) return;\n            \n            for (let i = currentIndex; i < batchEnd; i++) {\n                const index = wallIndices[i];\n                const node = this.nodes[index];\n                const nodeElement = this.nodesElements[index];\n                \n                node.is_wall = true;\n                nodeElement.classList.add(\"node-wall\");\n                // Add animation class based on frequency\n                if ((i - currentIndex) % config.animationFrequency === 0) {\n                    nodeElement.classList.add(\"node-wall-animation\");\n                }\n            }\n            \n            // Schedule next batch - get fresh config for delay\n            const timeoutId = setTimeout(() => {\n                this.animateWallsSequentially(wallIndices, batchEnd);\n            }, config.batchDelay);\n            \n            this.wallGenerationTimeouts.push(timeoutId);\n        });\n    }\n\n    stopWallGeneration() {\n        this.isGeneratingWalls = false;\n        // Clear all pending timeouts\n        this.wallGenerationTimeouts.forEach(timeoutId => clearTimeout(timeoutId));\n        this.wallGenerationTimeouts = [];\n    }\n\n    getWallAnimationConfig() {\n        // Read speed from StateManager for real-time updates\n        const speed = this.stateManager.getAnimationSpeed();\n        \n        switch (speed) {\n            case 'slow':\n                return {\n                    batchSize: 2,\n                    batchDelay: 120,\n                    animationFrequency: 1  // Animate every wall\n                };\n            case 'normal':\n                return {\n                    batchSize: 10,\n                    batchDelay: 40,\n                    animationFrequency: 2  // Animate every 2nd wall\n                };\n            case 'fast':\n                return {\n                    batchSize: 50,\n                    batchDelay: 8,\n                    animationFrequency: 5  // Animate every 5th wall\n                };\n            default:\n                return {\n                    batchSize: 10,\n                    batchDelay: 40,\n                    animationFrequency: 2\n                };\n        }\n    }\n\n    handleAlgoChange(newAlgo, currentAlgo) {\n        if (this.stateManager.getState()) return;\n        this.clearPaths();\n\n        const startNode = this.nodes.find((node) => node.is_start);\n        const finishNode = this.nodes.find((node) => node.is_finish);\n\n        const startNodeEl =\n            this.nodesElements[startNode.row * this.cols + startNode.col];\n        const finishNodeEl =\n            this.nodesElements[finishNode.row * this.cols + finishNode.col];\n\n        startNodeEl.classList.add(\"node-start\");\n        finishNodeEl.classList.add(\"node-finish\");\n\n        console.log(newAlgo);\n        console.log(currentAlgo);\n    }\n    /**\n     * clear all walls\n     */\n    clearGrid() {\n        if (this.stateManager.getState()) return;\n        \n        // Stop any ongoing wall generation\n        this.stopWallGeneration();\n        \n        this.clearPaths();\n\n        // Remove all walls instantly without animation\n        for (let i = 0; i < this.nodes.length; i++) {\n            const node = this.nodes[i];\n            const nodeElement = this.nodesElements[i];\n            if (node.is_wall) {\n                node.is_wall = false;\n                nodeElement.classList.remove(\"node-wall\", \"node-wall-animation\");\n            }\n        }\n    }\n\n    clearPaths() {\n        if (!this.nodes) return;\n\n        for (let i = 0; i < this.nodes.length; i++) {\n            const nodeElement = this.nodesElements[i];\n            // Check if the element has visited or updated colors and reset them\n            const bgColor = nodeElement.style.backgroundColor;\n            if (bgColor && (bgColor.includes(\"0, 0, 66\") || bgColor.includes(\"0, 190, 218\"))) {\n                nodeElement.style.backgroundColor = \"\";\n            }\n            // Remove path classes\n            nodeElement.classList.remove(\"node-path\", \"node-path-animation\", \n                \"node-visited-animation\", \"node-updated-animation\", \n                \"node-current\", \"node-current-animation\", \n                \"node-backtrack\", \"node-backtrack-animation\");\n        }\n    }\n\n    /**\n     * Handle events of the grid\n     * @param {MouseEvent} e - The Event object\n     * @param {string} event -  Name of the event (\"mousedown\", \"mousemove\", \"mouseup\")\n     */\n    async handleEvents(e, event) {\n        if (this.stateManager.getState()) return;\n        e.preventDefault();\n\n        const target = e.target;\n        if (!target || target.nodeName !== \"TD\") return;\n\n        let row = parseInt(target.id.split(\"-\")[1]);\n        let col = parseInt(target.id.split(\"-\")[2]);\n        let node = this.nodes[row * this.cols + col];\n\n        const classList = target.classList;\n\n        switch (event) {\n            case \"mousedown\":\n                this.is_mouse_pressed = true;\n                this.clearPaths();\n                if (classList.contains(\"node-start\")) {\n                    node.is_start = false;\n                    classList.remove(\"node-start\");\n                    this.currently_moving = \"node-start\";\n                    this.last_hoverd_node = target;\n                } else if (classList.contains(\"node-finish\")) {\n                    node.is_finish = false;\n                    classList.remove(\"node-finish\");\n                    this.currently_moving = \"node-finish\";\n                    this.last_hoverd_node = target;\n                } else {\n                    this.add_wall = !classList.contains(\"node-wall\");\n                    classList.toggle(\"node-wall\", this.add_wall);\n                    node.is_wall = this.add_wall;\n                }\n                break;\n\n            case \"mousemove\":\n                if (!this.is_mouse_pressed) return;\n                if (this.currently_moving) {\n                    if (this.last_hoverd_node) {\n                        this.last_hoverd_node.classList.remove(\n                            this.currently_moving\n                        );\n                    }\n                    classList.add(this.currently_moving);\n                    this.last_hoverd_node = target;\n                } else if (\n                    !(\n                        classList.contains(\"node-start\") ||\n                        classList.contains(\"node-finish\")\n                    )\n                ) {\n                    node.is_wall = this.add_wall;\n                    classList.toggle(\"node-wall\", this.add_wall);\n                }\n                break;\n\n            case \"mouseup\":\n                this.is_mouse_pressed = false;\n                this.add_wall = false;\n\n                if (this.currently_moving && this.last_hoverd_node) {\n                    let lrow = parseInt(this.last_hoverd_node.id.split(\"-\")[1]);\n                    let lcol = parseInt(this.last_hoverd_node.id.split(\"-\")[2]);\n                    const lnode = this.nodes[lrow * this.cols + lcol];\n                    if (this.last_hoverd_node.classList.contains(\"node-wall\")) {\n                        lnode.is_wall = false;\n                        this.last_hoverd_node.classList.remove(\"node-wall\");\n                    }\n                    lnode.is_start = this.currently_moving == \"node-start\";\n                    lnode.is_finish = this.currently_moving == \"node-finish\";\n                    this.last_hoverd_node.classList.add(this.currently_moving);\n                }\n\n                this.currently_moving = null;\n                this.last_hoverd_node = null;\n\n                break;\n        }\n    }\n}\n"]}