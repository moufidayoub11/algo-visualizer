{"version":3,"sources":["GridAnimator.js"],"names":["StateManager","AlgorithmsManager","Utils","VISITED_COLOR","CLOSED_COLOR","GridAnimator","constructor","this","stateManager","isAutoPlaying","isPaused","currentStep","steps","animationSpeed","lastFrameTime","animationFrameId","isActive","visualize","type","state","getState","nodes","getNodes","nodesElements","getNodeElements","length","setState","showControlButtons","algorithmsManager","dijkstra","aStar","depthFS","breadthFS","updateControlButtons","animate","currentTime","cleanup","executeStep","requestAnimationFrame","time","stepIndex","step","console","count","performStep","indices","animateVisited","animateUpdated","animateFinish","indice","node","nodeElement","is_finish","is_start","style","backgroundColor","is_wall","delay","originalStart","i","index","classList","contains","setTimeout","manipulateClasses","prevNodeElement","cancelAnimationFrame","hideControlButtons","reset","controlGroup","document","querySelector","pauseBtn","display","icon","setAttribute","lucide","createIcons","title","stepBackBtn","stepForwardBtn","innerHTML","disabled","canStepBack","canStep","pause","resume","togglePauseResume","isRunning","stepForward","stepBack","undoStep","undoVisited","undoUpdated","undoFinish","originalStartIndex","setSpeed","speed","slow","normal","fast","setAnimationSpeed","getProgress","Math","min"],"mappings":"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","file":"GridAnimator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\nimport AlgorithmsManager from \"../algorithms/AlgorithmsManager.js\";\nimport Utils from \"../utils/Utils.js\";\n\nconst VISITED_COLOR = \"rgba(0, 0, 66, 0.75)\";\nconst CLOSED_COLOR = \"rgba(0, 190, 218, 0.75)\";\n\nexport default class GridAnimator {\n    constructor() {\n        this.stateManager = new StateManager();\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.steps = [];\n        this.animationSpeed = 30; // milliseconds between steps\n        this.lastFrameTime = 0;\n        this.animationFrameId = null;\n        this.isActive = false;\n    }\n\n    async visualize(type) {\n        this.state = this.stateManager.getState();\n        this.nodes = this.stateManager.getNodes();\n        this.nodesElements = this.stateManager.getNodeElements();\n\n        if (this.state || !this.nodes.length || !this.nodesElements.length)\n            return;\n\n        this.stateManager.setState(true);\n        this.isActive = true;\n        this.isAutoPlaying = true;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.lastFrameTime = 0;\n        this.showControlButtons();\n\n        const algorithmsManager = new AlgorithmsManager(\n            this.stateManager.getNodes()\n        );\n\n        switch (type) {\n            case \"dijkstra\":\n                this.steps = algorithmsManager.dijkstra();\n                break;\n            case \"astar\":\n                this.steps = algorithmsManager.aStar();\n                break;\n            case \"dfs\":\n                this.steps = algorithmsManager.depthFS();\n                break;\n            case \"bfs\":\n                this.steps = algorithmsManager.breadthFS();\n                break;\n        }\n\n        this.updateControlButtons();\n        this.animate();\n    }\n\n    animate(currentTime = 0) {\n        if (!this.isActive) {\n            this.cleanup();\n            return;\n        }\n\n        // Only proceed if enough time has passed and we're auto-playing and not paused\n        if (this.isAutoPlaying && !this.isPaused && currentTime - this.lastFrameTime >= this.animationSpeed) {\n            if (this.currentStep < this.steps.length) {\n                this.executeStep(this.currentStep);\n                this.currentStep++;\n                this.lastFrameTime = currentTime;\n                \n                // Only update buttons when we reach the end\n                if (this.currentStep >= this.steps.length) {\n                    this.updateControlButtons();\n                }\n            } else {\n                // Animation complete\n                this.cleanup();\n                return;\n            }\n        }\n\n        this.animationFrameId = requestAnimationFrame((time) => this.animate(time));\n    }\n\n    executeStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= this.steps.length) return;\n        \n        const step = this.steps[stepIndex];\n        console.count(\"step\");\n        this.performStep(step);\n    }\n\n    performStep(step) {\n        const { type, indices } = step;\n\n        if (type === \"visited\") {\n            this.animateVisited(indices[0]);\n        } else if (type === \"updated\") {\n            this.animateUpdated(indices[0]);\n        } else if (type === \"finish\") {\n            this.animateFinish(indices);\n        }\n    }\n\n    animateVisited(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (node.is_finish || node.is_start) return;\n        nodeElement.style.backgroundColor = VISITED_COLOR;\n    }\n\n    animateUpdated(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (!node || node.is_finish || node.is_start || node.is_wall) return;\n        nodeElement.style.backgroundColor = CLOSED_COLOR;\n    }\n\n    animateFinish(indices) {\n        let delay = 0;\n        let originalStart = null;\n        \n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i];\n            const nodeElement = this.nodesElements[index];\n            \n            if (nodeElement.classList.contains(\"node-start\")) {\n                originalStart = nodeElement;\n            }\n            \n            setTimeout(() => {\n                Utils.manipulateClasses(nodeElement, [\"node-path\"]);\n                if (!nodeElement.classList.contains(\"node-finish\")) {\n                    Utils.manipulateClasses(nodeElement, [\"node-start\"]);\n                }\n                \n                // Remove start class from previous node\n                if (i > 0) {\n                    const prevNodeElement = this.nodesElements[indices[i-1]];\n                    if (!prevNodeElement.classList.contains(\"node-finish\")) {\n                        Utils.manipulateClasses(prevNodeElement, [], [\"node-start\"]);\n                    }\n                }\n                \n                // Restore original start if this is the last step\n                if (i === indices.length - 1 && originalStart) {\n                    setTimeout(() => {\n                        Utils.manipulateClasses(nodeElement, [], [\"node-start\"]);\n                        Utils.manipulateClasses(originalStart, [\"node-start\"]);\n                    }, this.animationSpeed);\n                }\n            }, delay);\n            \n            delay += this.animationSpeed;\n        }\n    }\n\n    cleanup() {\n        this.isActive = false;\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        this.hideControlButtons();\n        \n        // Use setTimeout to ensure state update happens after animation cleanup\n        setTimeout(() => {\n            this.stateManager.setState(false);\n        }, 0);\n    }\n\n    // Reset method for stopping animation\n    reset() {\n        this.isActive = false;\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.steps = [];\n        \n        // Ensure animation frame is cancelled immediately\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        \n        this.hideControlButtons();\n        \n        // Use setTimeout to ensure state update happens after current execution\n        setTimeout(() => {\n            this.stateManager.setState(false);\n        }, 0);\n    }\n\n    // Control button management\n    showControlButtons() {\n        const controlGroup = document.querySelector('.button-group.control-actions');\n        const pauseBtn = document.querySelector('.navbar-buttons-pause');\n        \n        if (controlGroup) {\n            controlGroup.style.display = 'flex';\n        }\n        \n        if (pauseBtn) {\n            const icon = pauseBtn.querySelector('i');\n            if (icon) {\n                icon.setAttribute('data-lucide', 'pause');\n                if (typeof lucide !== 'undefined') {\n                    lucide.createIcons();\n                }\n            }\n            pauseBtn.title = 'Pause';\n        }\n    }\n\n    hideControlButtons() {\n        const controlGroup = document.querySelector('.button-group.control-actions');\n        if (controlGroup) {\n            controlGroup.style.display = 'none';\n        }\n    }\n\n    updateControlButtons() {\n        const pauseBtn = document.querySelector('.navbar-buttons-pause');\n        const stepBackBtn = document.querySelector('.navbar-buttons-step-back');\n        const stepForwardBtn = document.querySelector('.navbar-buttons-step-forward');\n\n        if (pauseBtn) {\n            if (this.isPaused || !this.isAutoPlaying) {\n                pauseBtn.title = 'Resume';\n                pauseBtn.innerHTML = '<i data-lucide=\"play\"></i>';\n            } else if (this.isAutoPlaying) {\n                pauseBtn.title = 'Pause';\n                pauseBtn.innerHTML = '<i data-lucide=\"pause\"></i>';\n            }\n            \n            // Recreate the icon after setting innerHTML\n            if (typeof lucide !== 'undefined') {\n                lucide.createIcons();\n            }\n        }\n\n        // Enable/disable step buttons based on current position and active state\n        if (stepBackBtn) {\n            stepBackBtn.disabled = !this.canStepBack();\n        }\n        if (stepForwardBtn) {\n            stepForwardBtn.disabled = !this.canStep();\n        }\n    }\n\n    // Pause/Resume functionality\n    pause() {\n        if (!this.isActive) return;\n        this.isPaused = true;\n        this.isAutoPlaying = false;\n        this.updateControlButtons();\n    }\n\n    resume() {\n        if (!this.isActive) return;\n        this.isPaused = false;\n        this.isAutoPlaying = true;\n        this.updateControlButtons();\n    }\n\n    togglePauseResume() {\n        if (!this.isRunning()) return;\n        \n        if (this.isPaused) {\n            this.resume();\n        } else {\n            this.pause();\n        }\n    }\n\n    // Step functionality\n    stepForward() {\n        if (!this.canStep()) return;\n        \n        // Pause auto-playing when manually stepping\n        this.isAutoPlaying = false;\n        this.isPaused = true;\n        \n        this.executeStep(this.currentStep);\n        this.currentStep++;\n        \n        // Only update buttons if we've reached the end or beginning\n        if (this.currentStep >= this.steps.length || this.currentStep === 1) {\n            this.updateControlButtons();\n        }\n    }\n\n    stepBack() {\n        if (!this.canStepBack()) return;\n        \n        // Pause auto-playing when manually stepping\n        this.isAutoPlaying = false;\n        this.isPaused = true;\n        \n        this.currentStep--;\n        this.undoStep(this.currentStep);\n        \n        // Only update buttons if we've reached the beginning or moved from end\n        if (this.currentStep <= 0 || this.currentStep === this.steps.length - 1) {\n            this.updateControlButtons();\n        }\n    }\n\n    undoStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= this.steps.length) return;\n        \n        const step = this.steps[stepIndex];\n        const { type, indices } = step;\n\n        // Undo the visual effects of this step\n        if (type === \"visited\") {\n            this.undoVisited(indices[0]);\n        } else if (type === \"updated\") {\n            this.undoUpdated(indices[0]);\n        } else if (type === \"finish\") {\n            this.undoFinish(indices);\n        }\n    }\n\n    undoVisited(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (node.is_finish || node.is_start) return;\n        nodeElement.style.backgroundColor = \"\";\n    }\n\n    undoUpdated(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (!node || node.is_finish || node.is_start || node.is_wall) return;\n        nodeElement.style.backgroundColor = \"\";\n    }\n\n    undoFinish(indices) {\n        // Remove path visualization\n        for (let i = indices.length - 1; i >= 0; i--) {\n            const index = indices[i];\n            const nodeElement = this.nodesElements[index];\n            Utils.manipulateClasses(nodeElement, [], [\"node-path\", \"node-start\"]);\n        }\n        \n        // Restore original start node\n        if (indices.length > 0) {\n            const originalStartIndex = indices[0];\n            const originalStart = this.nodesElements[originalStartIndex];\n            Utils.manipulateClasses(originalStart, [\"node-start\"]);\n        }\n    }\n\n    // Speed control methods\n    setSpeed(speed) {\n        const speedMap = {\n            'slow': 100,\n            'normal': 30,\n            'fast': 5\n        };\n        this.animationSpeed = speedMap[speed] || 30;\n    }\n\n    setAnimationSpeed(speed) {\n        this.setSpeed(speed);\n    }\n\n    // Helper methods for better state management\n    isRunning() {\n        return this.isActive;\n    }\n\n    canStep() {\n        return this.isActive && this.currentStep < this.steps.length;\n    }\n\n    canStepBack() {\n        return this.isActive && this.currentStep > 0;\n    }\n\n    getProgress() {\n        if (!this.steps.length) return 0;\n        return Math.min(this.currentStep / this.steps.length, 1);\n    }\n}\n"]}