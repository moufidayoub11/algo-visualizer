{"version":3,"sources":["GridAnimator.js"],"names":["StateManager","AlgorithmsManager","Utils","VISITED_COLOR","CLOSED_COLOR","GridAnimator","constructor","this","stateManager","isAutoPlaying","isPaused","currentStep","steps","animationSpeed","lastFrameTime","animationFrameId","isActive","visualize","type","state","getState","nodes","getNodes","nodesElements","getNodeElements","length","setState","showControlButtons","algorithmsManager","dijkstra","aStar","depthFS","breadthFS","greedyBestFirst","jumpPointSearch","updateControlButtons","animate","currentTime","cleanup","executeStep","requestAnimationFrame","time","stepIndex","step","console","count","performStep","indices","animateVisited","animateUpdated","animateFinish","indice","node","nodeElement","is_finish","is_start","style","backgroundColor","is_wall","delay","originalStart","i","index","classList","contains","setTimeout","manipulateClasses","prevNodeElement","cancelAnimationFrame","hideControlButtons","reset","controlGroup","document","querySelector","pauseBtn","stepBackBtn","stepForwardBtn","remove","disabled","icon","setAttribute","lucide","createIcons","title","canStepBack","canStep","add","innerHTML","pause","resume","togglePauseResume","isRunning","stepForward","stepBack","undoStep","undoVisited","undoUpdated","undoFinish","originalStartIndex","setSpeed","speed","slow","normal","fast","setAnimationSpeed","getProgress","Math","min"],"mappings":"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","file":"GridAnimator.js","sourcesContent":["import StateManager from \"../StateManager.js\";\nimport AlgorithmsManager from \"../algorithms/AlgorithmsManager.js\";\nimport Utils from \"../utils/Utils.js\";\n\nconst VISITED_COLOR = \"rgba(0, 0, 66, 0.75)\";\nconst CLOSED_COLOR = \"rgba(0, 190, 218, 0.75)\";\n\nexport default class GridAnimator {\n    constructor() {\n        this.stateManager = new StateManager();\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.steps = [];\n        this.animationSpeed = 10; // milliseconds between steps\n        this.lastFrameTime = 0;\n        this.animationFrameId = null;\n        this.isActive = false;\n    }\n\n    async visualize(type) {\n        this.state = this.stateManager.getState();\n        this.nodes = this.stateManager.getNodes();\n        this.nodesElements = this.stateManager.getNodeElements();\n\n        if (this.state || !this.nodes.length || !this.nodesElements.length)\n            return;\n\n        this.stateManager.setState(true);\n        this.isActive = true;\n        this.isAutoPlaying = true;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.lastFrameTime = 0;\n        this.showControlButtons();\n\n        const algorithmsManager = new AlgorithmsManager(\n            this.stateManager.getNodes()\n        );\n\n        switch (type) {\n            case \"dijkstra\":\n                this.steps = algorithmsManager.dijkstra();\n                break;\n            case \"astar\":\n                this.steps = algorithmsManager.aStar();\n                break;\n            case \"dfs\":\n                this.steps = algorithmsManager.depthFS();\n                break;\n            case \"bfs\":\n                this.steps = algorithmsManager.breadthFS();\n                break;\n            case \"greedy\":\n                this.steps = algorithmsManager.greedyBestFirst();\n                break;\n            case \"jps\":\n                this.steps = algorithmsManager.jumpPointSearch();\n                break;\n        }\n\n        this.updateControlButtons();\n        this.animate();\n    }\n\n    animate(currentTime = 0) {\n        if (!this.isActive) {\n            this.cleanup();\n            return;\n        }\n\n        // Only proceed if enough time has passed and we're auto-playing and not paused\n        if (this.isAutoPlaying && !this.isPaused && currentTime - this.lastFrameTime >= this.animationSpeed) {\n            if (this.currentStep < this.steps.length) {\n                this.executeStep(this.currentStep);\n                this.currentStep++;\n                this.lastFrameTime = currentTime;\n                \n                // Only update buttons when we reach the end\n                if (this.currentStep >= this.steps.length) {\n                    this.updateControlButtons();\n                }\n            } else {\n                // Animation complete\n                this.cleanup();\n                return;\n            }\n        }\n\n        this.animationFrameId = requestAnimationFrame((time) => this.animate(time));\n    }\n\n    executeStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= this.steps.length) return;\n        \n        const step = this.steps[stepIndex];\n        console.count(\"step\");\n        this.performStep(step);\n    }\n\n    performStep(step) {\n        const { type, indices } = step;\n\n        if (type === \"visited\") {\n            this.animateVisited(indices[0]);\n        } else if (type === \"updated\") {\n            this.animateUpdated(indices[0]);\n        } else if (type === \"finish\") {\n            this.animateFinish(indices);\n        }\n    }\n\n    animateVisited(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (node.is_finish || node.is_start) return;\n        nodeElement.style.backgroundColor = VISITED_COLOR;\n    }\n\n    animateUpdated(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (!node || node.is_finish || node.is_start || node.is_wall) return;\n        nodeElement.style.backgroundColor = CLOSED_COLOR;\n    }\n\n    animateFinish(indices) {\n        let delay = 0;\n        let originalStart = null;\n        \n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i];\n            const nodeElement = this.nodesElements[index];\n            \n            if (nodeElement.classList.contains(\"node-start\")) {\n                originalStart = nodeElement;\n            }\n            \n            setTimeout(() => {\n                Utils.manipulateClasses(nodeElement, [\"node-path\"]);\n                if (!nodeElement.classList.contains(\"node-finish\")) {\n                    Utils.manipulateClasses(nodeElement, [\"node-start\"]);\n                }\n                \n                // Remove start class from previous node\n                if (i > 0) {\n                    const prevNodeElement = this.nodesElements[indices[i-1]];\n                    if (!prevNodeElement.classList.contains(\"node-finish\")) {\n                        Utils.manipulateClasses(prevNodeElement, [], [\"node-start\"]);\n                    }\n                }\n                \n                // Restore original start if this is the last step\n                if (i === indices.length - 1 && originalStart) {\n                    setTimeout(() => {\n                        Utils.manipulateClasses(nodeElement, [], [\"node-start\"]);\n                        Utils.manipulateClasses(originalStart, [\"node-start\"]);\n                    }, this.animationSpeed);\n                }\n            }, delay);\n            \n            delay += this.animationSpeed;\n        }\n    }\n\n    cleanup() {\n        this.isActive = false;\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        this.hideControlButtons();\n        \n        // Use setTimeout to ensure state update happens after animation cleanup\n        setTimeout(() => {\n            this.stateManager.setState(false);\n        }, 0);\n    }\n\n    // Reset method for stopping animation\n    reset() {\n        this.isActive = false;\n        this.isAutoPlaying = false;\n        this.isPaused = false;\n        this.currentStep = 0;\n        this.steps = [];\n        \n        // Ensure animation frame is cancelled immediately\n        if (this.animationFrameId) {\n            cancelAnimationFrame(this.animationFrameId);\n            this.animationFrameId = null;\n        }\n        \n        this.hideControlButtons();\n        \n        // Use setTimeout to ensure state update happens after current execution\n        setTimeout(() => {\n            this.stateManager.setState(false);\n        }, 0);\n    }\n\n    // Control button management\n    showControlButtons() {\n        const controlGroup = document.querySelector('.button-group.control-actions');\n        const pauseBtn = document.querySelector('.navbar-buttons-pause');\n        const stepBackBtn = document.querySelector('.navbar-buttons-step-back');\n        const stepForwardBtn = document.querySelector('.navbar-buttons-step-forward');\n        \n        // Enable the control group\n        if (controlGroup) {\n            controlGroup.classList.remove('disabled');\n        }\n        \n        // Enable all control buttons\n        if (pauseBtn) {\n            pauseBtn.disabled = false;\n            const icon = pauseBtn.querySelector('i');\n            if (icon) {\n                icon.setAttribute('data-lucide', 'pause');\n                if (typeof lucide !== 'undefined') {\n                    lucide.createIcons();\n                }\n            }\n            pauseBtn.title = 'Pause';\n        }\n        \n        if (stepBackBtn) {\n            stepBackBtn.disabled = !this.canStepBack();\n        }\n        \n        if (stepForwardBtn) {\n            stepForwardBtn.disabled = !this.canStep();\n        }\n    }\n\n    hideControlButtons() {\n        const controlGroup = document.querySelector('.button-group.control-actions');\n        const pauseBtn = document.querySelector('.navbar-buttons-pause');\n        const stepBackBtn = document.querySelector('.navbar-buttons-step-back');\n        const stepForwardBtn = document.querySelector('.navbar-buttons-step-forward');\n        \n        // Disable the control group\n        if (controlGroup) {\n            controlGroup.classList.add('disabled');\n        }\n        \n        // Disable all control buttons\n        if (pauseBtn) {\n            pauseBtn.disabled = true;\n        }\n        \n        if (stepBackBtn) {\n            stepBackBtn.disabled = true;\n        }\n        \n        if (stepForwardBtn) {\n            stepForwardBtn.disabled = true;\n        }\n    }\n\n    updateControlButtons() {\n        const pauseBtn = document.querySelector('.navbar-buttons-pause');\n        const stepBackBtn = document.querySelector('.navbar-buttons-step-back');\n        const stepForwardBtn = document.querySelector('.navbar-buttons-step-forward');\n\n        if (pauseBtn) {\n            if (this.isPaused || !this.isAutoPlaying) {\n                pauseBtn.title = 'Resume';\n                pauseBtn.innerHTML = '<i data-lucide=\"play\"></i>';\n            } else if (this.isAutoPlaying) {\n                pauseBtn.title = 'Pause';\n                pauseBtn.innerHTML = '<i data-lucide=\"pause\"></i>';\n            }\n            \n            // Recreate the icon after setting innerHTML\n            if (typeof lucide !== 'undefined') {\n                lucide.createIcons();\n            }\n        }\n\n        // Enable/disable step buttons based on current position and active state\n        if (stepBackBtn) {\n            stepBackBtn.disabled = !this.canStepBack();\n        }\n        if (stepForwardBtn) {\n            stepForwardBtn.disabled = !this.canStep();\n        }\n    }\n\n    // Pause/Resume functionality\n    pause() {\n        if (!this.isActive) return;\n        this.isPaused = true;\n        this.isAutoPlaying = false;\n        this.updateControlButtons();\n    }\n\n    resume() {\n        if (!this.isActive) return;\n        this.isPaused = false;\n        this.isAutoPlaying = true;\n        this.updateControlButtons();\n    }\n\n    togglePauseResume() {\n        if (!this.isRunning()) return;\n        \n        if (this.isPaused) {\n            this.resume();\n        } else {\n            this.pause();\n        }\n    }\n\n    // Step functionality\n    stepForward() {\n        if (!this.canStep()) return;\n        \n        // Pause auto-playing when manually stepping\n        this.isAutoPlaying = false;\n        this.isPaused = true;\n        this.updateControlButtons();\n        \n        this.executeStep(this.currentStep);\n        this.currentStep++;\n        \n        // Only update buttons if we've reached the end or beginning\n        if (this.currentStep >= this.steps.length || this.currentStep === 1) {\n            this.updateControlButtons();\n        }\n    }\n\n    stepBack() {\n        if (!this.canStepBack()) return;\n        \n        // Pause auto-playing when manually stepping\n        this.isAutoPlaying = false;\n        this.isPaused = true;\n        this.updateControlButtons();\n        \n        this.currentStep--;\n        this.undoStep(this.currentStep);\n        \n        // Only update buttons if we've reached the beginning or moved from end\n        if (this.currentStep <= 0 || this.currentStep === this.steps.length - 1) {\n            this.updateControlButtons();\n        }\n    }\n\n    undoStep(stepIndex) {\n        if (stepIndex < 0 || stepIndex >= this.steps.length) return;\n        \n        const step = this.steps[stepIndex];\n        const { type, indices } = step;\n\n        // Undo the visual effects of this step\n        if (type === \"visited\") {\n            this.undoVisited(indices[0]);\n        } else if (type === \"updated\") {\n            this.undoUpdated(indices[0]);\n        } else if (type === \"finish\") {\n            this.undoFinish(indices);\n        }\n    }\n\n    undoVisited(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (node.is_finish || node.is_start) return;\n        nodeElement.style.backgroundColor = \"\";\n    }\n\n    undoUpdated(indice) {\n        let node = this.nodes[indice];\n        let nodeElement = this.nodesElements[indice];\n\n        if (!node || node.is_finish || node.is_start || node.is_wall) return;\n        nodeElement.style.backgroundColor = \"\";\n    }\n\n    undoFinish(indices) {\n        // Remove path visualization\n        for (let i = indices.length - 1; i >= 0; i--) {\n            const index = indices[i];\n            const nodeElement = this.nodesElements[index];\n            Utils.manipulateClasses(nodeElement, [], [\"node-path\", \"node-start\"]);\n        }\n        \n        // Restore original start node\n        if (indices.length > 0) {\n            const originalStartIndex = indices[0];\n            const originalStart = this.nodesElements[originalStartIndex];\n            Utils.manipulateClasses(originalStart, [\"node-start\"]);\n        }\n    }\n\n    // Speed control methods\n    setSpeed(speed) {\n        const speedMap = {\n            'slow': 50,     // Slower but not too slow - 50ms between steps\n            'normal': 8,    // Much faster normal - 8ms between steps  \n            'fast': 1       // Ultra fast - 1ms between steps (almost instant)\n        };\n        this.animationSpeed = speedMap[speed] || 8;\n    }\n\n    setAnimationSpeed(speed) {\n        this.setSpeed(speed);\n    }\n\n    // Helper methods for better state management\n    isRunning() {\n        return this.isActive;\n    }\n\n    canStep() {\n        return this.isActive && this.currentStep < this.steps.length;\n    }\n\n    canStepBack() {\n        return this.isActive && this.currentStep > 0;\n    }\n\n    getProgress() {\n        if (!this.steps.length) return 0;\n        return Math.min(this.currentStep / this.steps.length, 1);\n    }\n}\n"]}